---
title: "SSF CLR fitting and prediction"
author: "Scott Forrest"
date: "`r Sys.Date()`"
output: html_document
editor_options: 
  chunk_output_type: inline
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


Import packages

```{r message = FALSE}

options(scipen=999)

# install.packages("clogitLasso")

library(tidyverse)
packages <- c("lubridate", "survival", "terra", "raster", "tictoc", "TwoStepCLogit", "ecospat", "beepr", "clogitL1", "clogitLasso", "ggpubr")
walk(packages, require, character.only = T)

```

For unscaled rasters

```{r}

xmin <- round(min(buffalo_CLR_year_harmonics$x2), digits = -2)
xmax <- round(max(buffalo_CLR_year_harmonics$x2), digits = -2)
ymin <- round(min(buffalo_CLR_year_harmonics$y2), digits = -2)
ymax <- round(max(buffalo_CLR_year_harmonics$y2), digits = -2)

# unscaled rasters
ndvi_stack <- rast("mapping/cropped rasters/ndvi_GEE_projected_watermask20230207.tif")
canopy <- rast("mapping/cropped rasters/canopy_cover.tif")
herby <- rast("mapping/cropped rasters/veg_herby.tif")
elev <- rast("mapping/cropped rasters/DEM_H_raster.tif")
# plot(elev < 1)
elev_0 <- terra::ifel(elev < 1, 1, elev)
elev_log <- log(elev_0)
# plot(elev_log)

crop_extent <- ext(xmin, xmax, ymin, ymax)

ndvi_stack_cropped <- terra::crop(ndvi_stack, crop_extent)
canopy_cropped <- terra::crop(canopy, crop_extent)
herby_cropped <- terra::crop(herby, crop_extent)
elev_log_cropped <- terra::crop(elev_log, crop_extent)

orig_extent <- ext(ndvi_stack_cropped)

# to set the origin at (0,0)
ext(ndvi_stack_cropped) <- c(xmin - xmin, xmax - xmin, ymin - ymin, ymax - ymin)
ext(canopy_cropped) <- c(xmin - xmin, xmax - xmin, ymin - ymin, ymax - ymin)
ext(herby_cropped) <- c(xmin - xmin, xmax - xmin, ymin - ymin, ymax - ymin)
ext(elev_log_cropped) <- c(xmin - xmin, xmax - xmin, ymin - ymin, ymax - ymin)

# plot(ndvi_stack_cropped)
# plot(canopy_cropped)
# plot(herby_cropped)
# plot(elev_cropped)

```

Using the lasso approach

```{r}

# set.seed(145)
# data parameters
K = 10 # number of strata
n = 5 # number in strata
m = 2 # cases per stratum
p = 20 # predictors

# generate data
y = rep(c(rep(1, m), rep(0, n-m)), K)
X = matrix (rnorm(K*n*p, 0, 1), ncol = p) # pure noise
strata = sort(rep(1:K, n))

par(mfrow = c(1,2))
# fit the conditional logistic model
clObj = clogitL1(y=y, x=X, strata)
plot(clObj, logX=TRUE)

# cross validation
clcvObj = cv.clogitL1(clObj)
plot(clcvObj)

```

Removing negative values from elevation

```{r}

buffalo_CLR_year_harmonics <- buffalo_CLR_year_harmonics %>% mutate(elev_0 = ifelse(DEM_H_end < 1, 1, DEM_H_end),
                                                                    elev_log = log(elev_0))
hist(buffalo_CLR_year_harmonics$DEM_H_end)
hist(buffalo_CLR_year_harmonics$elev_0)
hist(buffalo_CLR_year_harmonics$elev_log)

sum(is.na(buffalo_CLR_year_harmonics$elev_log))

```



```{r}

buffalo_ids <- unique(buffalo_CLR_year_harmonics$id)
which_buffalo <- 1

buffalo_data <- buffalo_CLR_year_harmonics %>% filter(id == buffalo_ids[which_buffalo]) %>% drop_na(cos_ta)

buffalo_lasso_unscaled <- buffalo_data %>% mutate(
  
  ndvi = ndvi_temporal,
  ndvi_s1 = ndvi_temporal * yday_s1,
  ndvi_s2 = ndvi_temporal * yday_s2,
  ndvi_s3 = ndvi_temporal * yday_s3,
  # ndvi_s4 = ndvi_temporal * yday_s4,
  ndvi_c1 = ndvi_temporal * yday_c1,
  ndvi_c2 = ndvi_temporal * yday_c2,
  ndvi_c3 = ndvi_temporal * yday_c3,
  # ndvi_c4 = ndvi_temporal * yday_c4,
  
  ndvi_sq = ndvi_temporal ^ 2,
  ndvi_sq_s1 = (ndvi_temporal ^ 2) * yday_s1,
  ndvi_sq_s2 = (ndvi_temporal ^ 2) * yday_s2,
  ndvi_sq_s3 = (ndvi_temporal ^ 2) * yday_s3,
  # ndvi_sq_s4 = (ndvi_temporal ^ 2) * yday_s4,
  ndvi_sq_c1 = (ndvi_temporal ^ 2) * yday_c1,
  ndvi_sq_c2 = (ndvi_temporal ^ 2) * yday_c2,
  ndvi_sq_c3 = (ndvi_temporal ^ 2) * yday_c3,
  # ndvi_sq_c4 = (ndvi_temporal ^ 2) * yday_c4,
  
  canopy = canopy_cover,
  canopy_s1 = canopy_cover * yday_s1,
  canopy_s2 = canopy_cover * yday_s2,
  canopy_s3 = canopy_cover * yday_s3,
  # canopy_s4 = canopy_cover * yday_s4,
  canopy_c1 = canopy_cover * yday_c1,
  canopy_c2 = canopy_cover * yday_c2,
  canopy_c3 = canopy_cover * yday_c3,
  # canopy_c4 = canopy_cover * yday_c4,
  
  canopy_sq = canopy_cover ^ 2,
  canopy_sq_s1 = (canopy_cover ^ 2) * yday_s1,
  canopy_sq_s2 = (canopy_cover ^ 2) * yday_s2,
  canopy_sq_s3 = (canopy_cover ^ 2) * yday_s3,
  # canopy_sq_s4 = (canopy_cover ^ 2) * yday_s4,
  canopy_sq_c1 = (canopy_cover ^ 2) * yday_c1,
  canopy_sq_c2 = (canopy_cover ^ 2) * yday_c2,
  canopy_sq_c3 = (canopy_cover ^ 2) * yday_c3,
  # canopy_sq_c4 = (canopy_cover ^ 2) * yday_c4,
  
  herby = veg_herby,
  herby_s1 = veg_herby * yday_s1,
  herby_s2 = veg_herby * yday_s2,
  herby_s3 = veg_herby * yday_s3,
  # herby_s4 = veg_herby * yday_s4,
  herby_c1 = veg_herby * yday_c1,
  herby_c2 = veg_herby * yday_c2,
  herby_c3 = veg_herby * yday_c3,
  # herby_c4 = veg_herby * yday_c4,
  
  elev_log = elev_log,
  elev_log_s1 = elev_log * yday_s1,
  elev_log_s2 = elev_log * yday_s2,
  elev_log_s3 = elev_log * yday_s3,
  elev_log_c1 = elev_log * yday_c1,
  elev_log_c2 = elev_log * yday_c2,
  elev_log_c3 = elev_log * yday_c3,
  # 
  elev_log_sq = (elev_log ^ 2),
  elev_log_sq_s1 = (elev_log ^ 2) * yday_s1,
  elev_log_sq_s2 = (elev_log ^ 2) * yday_s2,
  elev_log_sq_s3 = (elev_log ^ 2) * yday_s3,
  elev_log_sq_c1 = (elev_log ^ 2) * yday_c1,
  elev_log_sq_c2 = (elev_log ^ 2) * yday_c2,
  elev_log_sq_c3 = (elev_log ^ 2) * yday_c3,
  
  step_l = sl,
  step_l_s1 = sl * yday_s1,
  step_l_s2 = sl * yday_s2,
  step_l_s3 = sl * yday_s3,
  # step_l_s4 = sl * yday_s4,
  step_l_c1 = sl * yday_c1,
  step_l_c2 = sl * yday_c2,
  step_l_c3 = sl * yday_c3,
  # step_l_c4 = sl * yday_c4,

  log_step_l = log_sl,
  log_step_l_s1 = log_sl * yday_s1,
  log_step_l_s2 = log_sl * yday_s2,
  log_step_l_s3 = log_sl * yday_s3,
  # log_step_l_s4 = log_sl * yday_s4,
  log_step_l_c1 = log_sl * yday_c1,
  log_step_l_c2 = log_sl * yday_c2,
  log_step_l_c3 = log_sl * yday_c3,
  # log_step_l_c4 = log_sl * yday_c4,

  cos_turn_a = cos_ta,
  cos_turn_a_s1 = cos_ta * yday_s1,
  cos_turn_a_s2 = cos_ta * yday_s2,
  cos_turn_a_s3 = cos_ta * yday_s3,
  # cos_turn_a_s4 = cos_ta * yday_s4,
  cos_turn_a_c1 = cos_ta * yday_c1,
  cos_turn_a_c2 = cos_ta * yday_c2,
  cos_turn_a_c3 = cos_ta * yday_c3,
  # cos_turn_a_c4 = cos_ta * yday_c4,
  
  .keep = "none"
  
)

# mean_vals <- apply(buffalo_lasso_unscaled, 2, mean)
# sd_vals <- apply(buffalo_lasso_unscaled, 2, sd)
# scaling_attributes <- data.frame(variable = names(buffalo_lasso_unscaled), mean = mean_vals, sd = sd_vals)

buffalo_lasso_scaled <- scale(buffalo_lasso_unscaled)
# sum(is.na(buffalo_lasso_scaled))

mean_vals <- attr(buffalo_lasso_scaled, "scaled:center")
sd_vals <- attr(buffalo_lasso_scaled, "scaled:scale")
scaling_attributes <- data.frame(variable = names(buffalo_lasso_unscaled), mean = mean_vals, sd = sd_vals)

# generate data
y = buffalo_data$y
X = data.matrix(buffalo_lasso_scaled)
strata = buffalo_data$step_id

# attr(X, "dimnames") <- NULL

# par(mfrow = c(1,2))
# fit the conditional logistic model
tic()
cl_buffalo = clogitL1(y=y, 
                      x=X, 
                      strata, 
                       # numLambda = 100,
                       minLambdaRatio = 1e-3,
                      alpha = 1)
toc()
plot(cl_buffalo, logX=TRUE)

# cross validation
tic()
clcv_buffalo = cv.clogitL1(cl_buffalo, numFolds = 4)
toc()
plot(clcv_buffalo)

beep(sound = 2)

```

Just plotting 

```{r}

plot(cl_buffalo, logX=TRUE)
plot(clcv_buffalo)

# summary(cl_buffalo)
summary(clcv_buffalo)

```

Population level estimates (averaging over individuals)

```{r}

mean_vals_list <- vector(mode = "list", length = length(buffalo_ids))
sd_vals_list <- vector(mode = "list", length = length(buffalo_ids))
scaling_attributes_list <- vector(mode = "list", length = length(buffalo_ids))
cl_buffalo_list <- vector(mode = "list", length = length(buffalo_ids))
clcv_buffalo_list <- vector(mode = "list", length = length(buffalo_ids))
coefs_lasso_list <- vector(mode = "list", length = length(buffalo_ids))

for(i in 1:length(buffalo_ids)) {

buffalo_data <- buffalo_CLR_year_harmonics %>% filter(id == buffalo_ids[i]) %>% drop_na(cos_ta)

buffalo_lasso_unscaled <- buffalo_data %>% mutate(
  
  ndvi = ndvi_temporal,
  ndvi_s1 = ndvi_temporal * yday_s1,
  ndvi_s2 = ndvi_temporal * yday_s2,
  ndvi_s3 = ndvi_temporal * yday_s3,
  # ndvi_s4 = ndvi_temporal * yday_s4,
  ndvi_c1 = ndvi_temporal * yday_c1,
  ndvi_c2 = ndvi_temporal * yday_c2,
  ndvi_c3 = ndvi_temporal * yday_c3,
  # ndvi_c4 = ndvi_temporal * yday_c4,
  
  ndvi_sq = ndvi_temporal ^ 2,
  ndvi_sq_s1 = (ndvi_temporal ^ 2) * yday_s1,
  ndvi_sq_s2 = (ndvi_temporal ^ 2) * yday_s2,
  ndvi_sq_s3 = (ndvi_temporal ^ 2) * yday_s3,
  # ndvi_sq_s4 = (ndvi_temporal ^ 2) * yday_s4,
  ndvi_sq_c1 = (ndvi_temporal ^ 2) * yday_c1,
  ndvi_sq_c2 = (ndvi_temporal ^ 2) * yday_c2,
  ndvi_sq_c3 = (ndvi_temporal ^ 2) * yday_c3,
  # ndvi_sq_c4 = (ndvi_temporal ^ 2) * yday_c4,
  
  canopy = canopy_cover,
  canopy_s1 = canopy_cover * yday_s1,
  canopy_s2 = canopy_cover * yday_s2,
  canopy_s3 = canopy_cover * yday_s3,
  # canopy_s4 = canopy_cover * yday_s4,
  canopy_c1 = canopy_cover * yday_c1,
  canopy_c2 = canopy_cover * yday_c2,
  canopy_c3 = canopy_cover * yday_c3,
  # canopy_c4 = canopy_cover * yday_c4,
  
  canopy_sq = canopy_cover ^ 2,
  canopy_sq_s1 = (canopy_cover ^ 2) * yday_s1,
  canopy_sq_s2 = (canopy_cover ^ 2) * yday_s2,
  canopy_sq_s3 = (canopy_cover ^ 2) * yday_s3,
  # canopy_sq_s4 = (canopy_cover ^ 2) * yday_s4,
  canopy_sq_c1 = (canopy_cover ^ 2) * yday_c1,
  canopy_sq_c2 = (canopy_cover ^ 2) * yday_c2,
  canopy_sq_c3 = (canopy_cover ^ 2) * yday_c3,
  # canopy_sq_c4 = (canopy_cover ^ 2) * yday_c4,
  
  herby = veg_herby,
  herby_s1 = veg_herby * yday_s1,
  herby_s2 = veg_herby * yday_s2,
  herby_s3 = veg_herby * yday_s3,
  # herby_s4 = veg_herby * yday_s4,
  herby_c1 = veg_herby * yday_c1,
  herby_c2 = veg_herby * yday_c2,
  herby_c3 = veg_herby * yday_c3,
  # herby_c4 = veg_herby * yday_c4,
  
  elev_log = elev_log,
  elev_log_s1 = elev_log * yday_s1,
  elev_log_s2 = elev_log * yday_s2,
  elev_log_s3 = elev_log * yday_s3,
  # elev_log_s4 = elev_log * yday_s4,
  elev_log_c1 = elev_log * yday_c1,
  elev_log_c2 = elev_log * yday_c2,
  elev_log_c3 = elev_log * yday_c3,
  # elev_log_c4 = elev_log * yday_c4,
  
  elev_log_sq = (elev_log ^ 2),
  elev_log_sq_s1 = (elev_log ^ 2) * yday_s1,
  elev_log_sq_s2 = (elev_log ^ 2) * yday_s2,
  elev_log_sq_s3 = (elev_log ^ 2) * yday_s3,
  # elev_log_sq_s4 = (elev_log ^ 2) * yday_s4,
  elev_log_sq_c1 = (elev_log ^ 2) * yday_c1,
  elev_log_sq_c2 = (elev_log ^ 2) * yday_c2,
  elev_log_sq_c3 = (elev_log ^ 2) * yday_c3,
  # elev_log_sq_c4 = (elev_log ^ 2) * yday_c4,
  
  step_l = sl,
  step_l_s1 = sl * yday_s1,
  step_l_s2 = sl * yday_s2,
  step_l_s3 = sl * yday_s3,
  # step_l_s4 = sl * yday_s4,
  step_l_c1 = sl * yday_c1,
  step_l_c2 = sl * yday_c2,
  step_l_c3 = sl * yday_c3,
  # step_l_c4 = sl * yday_c4,

  log_step_l = log_sl,
  log_step_l_s1 = log_sl * yday_s1,
  log_step_l_s2 = log_sl * yday_s2,
  log_step_l_s3 = log_sl * yday_s3,
  # log_step_l_s4 = log_sl * yday_s4,
  log_step_l_c1 = log_sl * yday_c1,
  log_step_l_c2 = log_sl * yday_c2,
  log_step_l_c3 = log_sl * yday_c3,
  # log_step_l_c4 = log_sl * yday_c4,

  cos_turn_a = cos_ta,
  cos_turn_a_s1 = cos_ta * yday_s1,
  cos_turn_a_s2 = cos_ta * yday_s2,
  cos_turn_a_s3 = cos_ta * yday_s3,
  # cos_turn_a_s4 = cos_ta * yday_s4,
  cos_turn_a_c1 = cos_ta * yday_c1,
  cos_turn_a_c2 = cos_ta * yday_c2,
  cos_turn_a_c3 = cos_ta * yday_c3,
  # cos_turn_a_c4 = cos_ta * yday_c4,
  
  .keep = "none"
  
)

buffalo_lasso_scaled <- scale(buffalo_lasso_unscaled)

mean_vals_list[[i]] <- attr(buffalo_lasso_scaled, "scaled:center")
sd_vals_list[[i]] <- attr(buffalo_lasso_scaled, "scaled:scale")
scaling_attributes_list[[i]] <- data.frame(variable = names(buffalo_lasso_unscaled), mean = mean_vals_list[[i]], sd = sd_vals_list[[i]])

# to get just scaling coefficients uncomment the closing curly bracket - this will loop over the dataset creation and scaling
# }

# organise data for clogitL1 function
y = buffalo_data$y
X = data.matrix(buffalo_lasso_scaled)
strata = buffalo_data$step_id

# fit the conditional logistic model
tic()
cl_buffalo_list[[i]] <- clogitL1(y=y, 
                      x=X, 
                      strata, 
                       # numLambda = 100,
                       # minLambdaRatio = 1e-8
                      alpha = 1)
toc()
plot(cl_buffalo_list[[i]], logX=TRUE)

# cross validation
tic()
clcv_buffalo_list[[i]] <- cv.clogitL1(cl_buffalo_list[[i]], numFolds = 4)
toc()
plot(clcv_buffalo_list[[i]])

# creating data frame of parameters
coefs_lasso_list[[i]] <- data.frame("coefs" = attr(X, "dimnames")[[2]],
                          scaling_attributes_list[[i]],
                          "beta_unpen_scl" = cl_buffalo_list[[i]]$beta[101,], 
                          "beta_CV_scl" = summary(clcv_buffalo_list[[i]])$beta_minCV,
                          "beta_CV1se_scl" = summary(clcv_buffalo_list[[i]])$beta_minCV1se)

}

beep(sound = 2)

```

Saving model fit objects

```{r}

# cl_buffalo_list_without_elev2 <- cl_buffalo_list
# clcv_buffalo_list_without_elev2 <- clcv_buffalo_list

# cl_buffalo_list <- cl_buffalo_list_without_elev2
# clcv_buffalo_list <- clcv_buffalo_list_without_elev2

# cl_buffalo_list_with_elev2 <- cl_buffalo_list
# clcv_buffalo_list_with_elev2 <- clcv_buffalo_list

cl_buffalo_list <- cl_buffalo_list_with_elev2
clcv_buffalo_list <- clcv_buffalo_list_with_elev2

```


Plotting

```{r}

for(i in 1:length(buffalo_ids)) {
plot(cl_buffalo_list[[i]], logX=TRUE)
plot(clcv_buffalo_list[[i]])
}

```


Creating data frame from list of lasso models

```{r}

betas_list <- vector(mode = "list", length = length(buffalo_ids))

# rescaling parameters back to natural scale
for(i in 1:length(buffalo_ids)) {
  
  # creating data frame of parameters
  coefs_lasso_list[[i]] <- data.frame("coefs" = attr(X, "dimnames")[[2]],
                            scaling_attributes_list[[i]],
                            "beta_unpen_scl" = cl_buffalo_list[[i]]$beta[101,], 
                            "beta_CV_scl" = summary(clcv_buffalo_list[[i]])$beta_minCV,
                            "beta_CV1se_scl" = summary(clcv_buffalo_list[[i]])$beta_minCV1se) %>% 
    
    mutate(mean = scaling_attributes_list[[i]]$mean,
           sd = scaling_attributes_list[[i]]$sd) %>% 
    
    mutate(beta_unpen_nat = (beta_unpen_scl / sd),
           beta_CV_nat = (beta_CV_scl / sd),
           beta_CV1se_nat = (beta_CV1se_scl / sd)
           # id = NULL
           ) #  + mean # buffalo_ids[i]
  
  betas_list[[i]] <- coefs_lasso_list[[i]] %>% mutate(beta_unpen_nat = (beta_unpen_scl / sd),
                                                      beta_CV_nat = (beta_CV_scl / sd),
                                                      beta_CV1se_nat = (beta_CV1se_scl / sd),
                                                      .keep = "used")

}

# Convert list elements into an array
betas_array <- array(unlist(betas_list), dim = c(nrow(betas_list[[1]]), ncol(betas_list[[1]]), length(betas_list)))

coefs_lasso_avg <- data.frame(id = "mean",
                              coef = coefs_lasso_list[[1]][,1],
                              apply(betas_array, 1:2, mean, na.rm = TRUE))

coefs_lasso_sd <- data.frame(id = "sd",
                             coef = coefs_lasso_list[[1]][,1], 
                             apply(betas_array, 1:2, sd, na.rm = TRUE))

colnames(coefs_lasso_avg) <- c("id", "coefs", colnames(betas_list[[1]]))
colnames(coefs_lasso_sd) <- c("id", "coefs", colnames(betas_list[[1]]))
coefs_lasso_avg
coefs_lasso_sd 

betas_df <- bind_rows(betas_list)
row.names(betas_df) <- NULL
betas_df <- data.frame(id = as.character(rep(buffalo_ids, each = nrow(betas_list[[1]]))), 
                       coefs = rep(row.names(betas_list[[1]]), length(betas_list)), 
                       betas_df)

betas_df_all <- bind_rows(betas_df, coefs_lasso_avg, coefs_lasso_sd)
betas_df_all$sd <- NULL

betas_df_long <- pivot_longer(betas_df_all, cols = !1:2, names_to = "model_fit")

```



```{r}

betas_df_long %>% dplyr::filter(model_fit == "beta_CV1se_scl") %>% ggplot() +
  geom_boxplot(aes(x = coefs, y = value)) + 
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))

```

Reconstructing LASSO coefficients

For single model

```{r}

# coefs <- attr(X, "dimnames")[[2]]
# coef_betas_CV <- summary(clcv_buffalo)$beta_minCV
# coef_betas_CV1se <- summary(clcv_buffalo)$beta_minCV1se
# coef_betas_unpen <- cl_buffalo$beta[101,]

# rescaling parameters back to natural scale

# coefs_lasso <- data.frame("coefs" = attr(X, "dimnames")[[2]],
#                           scaling_attributes,
#                           "beta_unpen_scl" = cl_buffalo$beta[101,], 
#                           "beta_CV_scl" = summary(clcv_buffalo)$beta_minCV,
#                           "beta_CV1se_scl" = summary(clcv_buffalo)$beta_minCV1se)
# 
# coefs_lasso <- coefs_lasso %>% mutate(beta_unpen_nat = (beta_unpen_scl / sd),
#                                       beta_CV_nat = (beta_CV_scl / sd),
#                                       beta_CV1se_nat = (beta_CV1se_scl / sd)) #  + mean

```

For population level models

```{r}

# for population level estimates
coefs_lasso <- coefs_lasso_avg

yday <- seq(0,365,1)
yday_harmonics_df <- data.frame("linear_term" = rep(1, length(yday)),
                                "yday_s1" = sin(2*pi*yday/365),
                                "yday_s2" = sin(4*pi*yday/365),
                                "yday_s3" = sin(6*pi*yday/365),
                                # "yday_s4" = sin(8*pi*yday/365),
                                "yday_c1" = cos(2*pi*yday/365),
                                "yday_c2" = cos(4*pi*yday/365),
                                "yday_c3" = cos(6*pi*yday/365))
                                # "yday_c4" = cos(8*pi*yday/365))

# scaled
# model_fit <- "coef_betas_unpen_scl"
# model_fit <- "beta_CV_scl"
model_fit <- "beta_CV1se_scl"
# natural scale
# model_fit <- "coef_betas_unpen_nat"
# model_fit <- "beta_CV_nat"
model_fit <- "beta_CV1se_nat"

harmonics_df <- data.frame("yday" = yday,
                           "ndvi" = as.numeric(coefs_lasso %>% dplyr::filter(grepl("ndvi", coefs) & !grepl("sq", coefs)) %>% 
                                                    dplyr::select(all_of(model_fit)) %>% unlist() %>% as.numeric() 
                                                  %*% t(as.matrix(yday_harmonics_df))),
                           "ndvi_2" = as.numeric(coefs_lasso %>% dplyr::filter(grepl("ndvi_sq", coefs)) %>% 
                                                    dplyr::select(all_of(model_fit)) %>% unlist() %>% as.numeric() 
                                                  %*% t(as.matrix(yday_harmonics_df))),
                           "canopy" = as.numeric(coefs_lasso %>% dplyr::filter(grepl("canopy", coefs) & !grepl("sq", coefs)) %>% 
                                                    dplyr::select(all_of(model_fit)) %>% unlist() %>% as.numeric() 
                                                  %*% t(as.matrix(yday_harmonics_df))),
                           "canopy_2" = as.numeric(coefs_lasso %>% dplyr::filter(grepl("canopy_sq", coefs)) %>% 
                                                    dplyr::select(all_of(model_fit)) %>% unlist() %>% as.numeric() 
                                                  %*% t(as.matrix(yday_harmonics_df))),
                           "elev" = as.numeric(coefs_lasso %>% dplyr::filter(grepl("elev", coefs) & !grepl("sq", coefs)) %>% 
                                                    dplyr::select(all_of(model_fit)) %>% unlist() %>% as.numeric() 
                                                  %*% t(as.matrix(yday_harmonics_df))),
                           "elev_2" = as.numeric(coefs_lasso %>% dplyr::filter(grepl("elev_log_sq", coefs)) %>%
                                                    dplyr::select(all_of(model_fit)) %>% unlist() %>% as.numeric()
                                                  %*% t(as.matrix(yday_harmonics_df))),
                           "herby" = as.numeric(coefs_lasso %>% dplyr::filter(grepl("herby", coefs)) %>% 
                                                    dplyr::select(all_of(model_fit)) %>% unlist() %>% as.numeric() 
                                                  %*% t(as.matrix(yday_harmonics_df))),
                           "sl" = as.numeric(coefs_lasso %>% dplyr::filter(grepl("step", coefs) & !grepl("log", coefs)) %>% 
                                                    dplyr::select(all_of(model_fit)) %>% unlist() %>% as.numeric() 
                                                  %*% t(as.matrix(yday_harmonics_df))),
                           "log_sl" = as.numeric(coefs_lasso %>% dplyr::filter(grepl("log_step", coefs)) %>% 
                                                    dplyr::select(all_of(model_fit)) %>% unlist() %>% as.numeric() 
                                                  %*% t(as.matrix(yday_harmonics_df))),
                           "cos_ta" = as.numeric(coefs_lasso %>% dplyr::filter(grepl("cos", coefs)) %>% 
                                                    dplyr::select(all_of(model_fit)) %>% unlist() %>% as.numeric() 
                                                  %*% t(as.matrix(yday_harmonics_df))))

```


Creating for each individual/mean+sd

```{r}

# scaled
# model_fit <- "coef_betas_unpen_scl"
model_fit <- "beta_CV_scl"
model_fit <- "beta_CV1se_scl"
# natural scale
# model_fit <- "coef_betas_unpen_nat"
# model_fit <- "beta_CV_nat"
model_fit <- "beta_CV1se_nat"

harmonics_df_list <- vector(mode = "list", length = length(unique(betas_df_long$id)))

for(i in 1:length(unique(betas_df_long$id))) {

coefs_lasso <- betas_df_all %>% dplyr::filter(id == unique(betas_df_long$id)[i])

harmonics_df_list[[i]] <- data.frame("id" = unique(betas_df_long$id)[i],
                                      "yday" = yday,
                                     "ndvi" = as.numeric(coefs_lasso %>% dplyr::filter(grepl("ndvi", coefs) & !grepl("sq", coefs)) %>% 
                                                              dplyr::select(all_of(model_fit)) %>% unlist() %>% as.numeric() 
                                                            %*% t(as.matrix(yday_harmonics_df))),
                                     "ndvi_2" = as.numeric(coefs_lasso %>% dplyr::filter(grepl("ndvi_sq", coefs)) %>% 
                                                              dplyr::select(all_of(model_fit)) %>% unlist() %>% as.numeric() 
                                                            %*% t(as.matrix(yday_harmonics_df))),
                                     "canopy" = as.numeric(coefs_lasso %>% dplyr::filter(grepl("canopy", coefs) & !grepl("sq", coefs)) %>% 
                                                              dplyr::select(all_of(model_fit)) %>% unlist() %>% as.numeric() 
                                                            %*% t(as.matrix(yday_harmonics_df))),
                                     "canopy_2" = as.numeric(coefs_lasso %>% dplyr::filter(grepl("canopy_sq", coefs)) %>% 
                                                              dplyr::select(all_of(model_fit)) %>% unlist() %>% as.numeric() 
                                                            %*% t(as.matrix(yday_harmonics_df))),
                                     "elev" = as.numeric(coefs_lasso %>% dplyr::filter(grepl("elev", coefs) & !grepl("sq", coefs)) %>% 
                                                              dplyr::select(all_of(model_fit)) %>% unlist() %>% as.numeric() 
                                                            %*% t(as.matrix(yday_harmonics_df))),
                                     "elev_2" = as.numeric(coefs_lasso %>% dplyr::filter(grepl("elev_log_sq", coefs)) %>%
                                                              dplyr::select(all_of(model_fit)) %>% unlist() %>% as.numeric()
                                                            %*% t(as.matrix(yday_harmonics_df))),
                                     "herby" = as.numeric(coefs_lasso %>% dplyr::filter(grepl("herby", coefs)) %>% 
                                                              dplyr::select(all_of(model_fit)) %>% unlist() %>% as.numeric() 
                                                            %*% t(as.matrix(yday_harmonics_df))),
                                     "sl" = as.numeric(coefs_lasso %>% dplyr::filter(grepl("step", coefs) & !grepl("log", coefs)) %>% 
                                                              dplyr::select(all_of(model_fit)) %>% unlist() %>% as.numeric() 
                                                            %*% t(as.matrix(yday_harmonics_df))),
                                     "log_sl" = as.numeric(coefs_lasso %>% dplyr::filter(grepl("log_step", coefs)) %>% 
                                                              dplyr::select(all_of(model_fit)) %>% unlist() %>% as.numeric() 
                                                            %*% t(as.matrix(yday_harmonics_df))),
                                     "cos_ta" = as.numeric(coefs_lasso %>% dplyr::filter(grepl("cos", coefs)) %>% 
                                                              dplyr::select(all_of(model_fit)) %>% unlist() %>% as.numeric() 
                                                            %*% t(as.matrix(yday_harmonics_df))))

}

harmonics_df_all <- bind_rows(harmonics_df_list)
harmonics_df_long <- pivot_longer(harmonics_df_all, cols = !1:2)

# scaled
harmonics_df_all_scaled <- harmonics_df_all
harmonics_df_long_scaled <- harmonics_df_long

# natural scale
harmonics_df_all_nat <- harmonics_df_all
harmonics_df_long_nat <- harmonics_df_long

```

Plotting for all individuals

```{r}

harmonics_df_long <- harmonics_df_long_scaled
# harmonics_df_long <- harmonics_df_long_nat

ggplot() +
  geom_path(data = harmonics_df_long %>% dplyr::filter(!id %in% c("mean", "sd")),
            aes(x = yday, y = value, colour = name, group = interaction(name, id)),
            alpha = 0.2) +
  geom_path(data = harmonics_df_long %>% dplyr::filter(id %in% c("mean")), 
            aes(x = yday, y = value, colour = name, group = interaction(name, id)),
            alpha = 1) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  scale_y_continuous(expression(Time-varying~parameter~values~beta)) +
  theme_classic()


ggplot() +
  # geom_path(data = harmonics_df_long %>% dplyr::filter(id %in% "mean"), 
  #           aes(x = yday, y = value, colour = name, group = interaction(name, id)),
  #           alpha = 0.2) +
  geom_path(data = harmonics_df_long %>% dplyr::filter(id %in% c("mean")), 
            aes(x = yday, y = value, colour = name, group = interaction(name, id)),
            alpha = 1) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  scale_y_continuous(expression(Time-varying~parameter~values~beta)) +
  theme_classic()

ggplot() +
  # geom_path(data = harmonics_df_long %>% dplyr::filter(id %in% "mean"), 
  #           aes(x = yday, y = value, colour = name, group = interaction(name, id)),
  #           alpha = 0.2) +
  geom_path(data = harmonics_df_long %>% dplyr::filter(id %in% c("mean") & name %in% c("sl", "log_sl", "cos_ta")), 
            aes(x = yday, y = value, colour = name, group = interaction(name, id)),
            alpha = 1) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  scale_y_continuous(expression(Time-varying~parameter~values~beta)) +
  theme_classic()


for(i in 1:10) {

plot <- ggplot() +
  geom_path(data = harmonics_df_long %>% dplyr::filter(!id %in% c("mean", "sd") & name == unique(harmonics_df_long$name[i])), 
            aes(x = yday, y = value, group = interaction(name, id)), 
            colour = "grey",
            alpha = 0.5) +
  geom_path(data = harmonics_df_long %>% dplyr::filter(id %in% c("mean") & name == unique(harmonics_df_long$name[i])), 
            aes(x = yday, y = value, colour = name, group = interaction(name, id)),
            alpha = 1) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  scale_y_continuous(expression(Time-varying~parameter~values~beta)) +
  theme_classic()

print(plot)
  
}

```

Creating two dimensional selection plots

Contour plot for NDVI

```{r}

harmonics_df_mean <- harmonics_df_all_nat %>% filter(id == "mean")

ndvi_min <- min(buffalo_CLR_year_harmonics$ndvi_temporal)
ndvi_max <- max(buffalo_CLR_year_harmonics$ndvi_temporal)
ndvi_seq <- seq(ndvi_min, ndvi_max, by = 0.01)

# Create empty data frame
ndvi_fresponse_df <- data.frame(matrix(ncol = nrow(harmonics_df_mean), nrow = length(ndvi_seq)))
for(i in 1:nrow(harmonics_df_mean)) {
  # Assign the vector as a column to the dataframe
  ndvi_fresponse_df[,i] <- (harmonics_df_mean$ndvi[i] * ndvi_seq) + (harmonics_df_mean$ndvi_2[i] * (ndvi_seq ^ 2))
}

ndvi_fresponse_df <- data.frame(ndvi_seq, ndvi_fresponse_df)
colnames(ndvi_fresponse_df) <- c("ndvi", yday)
ndvi_fresponse_long <- pivot_longer(ndvi_fresponse_df, cols = !1, names_to = "yday")

max(ndvi_fresponse_long$value) # 0.4418052

ndvi_natural <- ggplot(data = ndvi_fresponse_long, aes(x = as.numeric(yday), y = ndvi)) +
  geom_point(aes(colour = value)) + # colour = "white"
  geom_contour(aes(z = value), breaks = seq(0, 1.75, 0.125), colour = "black", linewidth = 0.25, linetype = "dashed") +
  geom_contour(aes(z = value), breaks = seq(-0, -5, -0.125), colour = "red", linewidth = 0.25, linetype = "dashed") +
  geom_contour(aes(z = value), breaks = 0, colour = "black", linewidth = 0.5) +
  geom_vline(xintercept = 121, alpha = 0.25) +
  geom_vline(xintercept = 304, alpha = 0.25) +
  scale_x_continuous("Day of the year") +
  scale_y_continuous("NDVI value", breaks = seq(-1, 1, 0.25)) +
  scale_colour_viridis_c("Selection") +
  # ggtitle("NDVI") +
  theme_classic() +
  theme(legend.position = "none")

ndvi_natural

# ggsave(paste("outputs/plots/clr_fitting/clr_lasso_ndvi_quad_20230622.png", sep = ""),
#   width=150, height=90, units="mm", dpi = 300)

```

```{r}

elev_min <- min(buffalo_CLR_year_harmonics$elev_log)
elev_max <- max(buffalo_CLR_year_harmonics$elev_log)
elev_seq <- seq(elev_min, elev_max, by = 0.01)

# Create empty data frame
elev_fresponse_df <- data.frame(matrix(ncol = nrow(harmonics_df_mean), nrow = length(elev_seq)))
for(i in 1:nrow(harmonics_df_mean)) {
  # Assign the vector as a column to the dataframe
  elev_fresponse_df[,i] <- (harmonics_df_mean$elev[i] * elev_seq) + (harmonics_df_mean$elev_2[i] * (elev_seq ^ 2))
}

elev_fresponse_df <- data.frame(exp(elev_seq), elev_fresponse_df)
colnames(elev_fresponse_df) <- c("elev", yday)
elev_fresponse_long <- pivot_longer(elev_fresponse_df, cols = !1, names_to = "yday")

max(elev_fresponse_long$value) # 0.4475095

elev_natural <- ggplot(data = elev_fresponse_long, aes(x = as.numeric(yday), y = elev)) +
  geom_point(aes(colour = value)) +
  geom_contour(aes(z = value), breaks = seq(0, 3, 0.125), colour = "black", linewidth = 0.25, linetype = "dashed") + # 
  geom_contour(aes(z = value), breaks = seq(-0, -15, -0.125), colour = "red", linewidth = 0.25, linetype = "dashed") + # 
  geom_contour(aes(z = value), breaks = 0, colour = "black", linewidth = 0.5) +
  geom_vline(xintercept = 121, alpha = 0.25) +
  geom_vline(xintercept = 304, alpha = 0.25) +
  scale_x_continuous("Day of the year") +
  scale_y_continuous("Elevation (m)") +
  scale_colour_viridis_c("Selection") +
  # ggtitle("Elevation") +
  theme_classic() +
  theme(legend.position = "none")

elev_natural

# ggsave(paste("outputs/plots/clr_fitting/clr_lasso_elev_quad_20230622.png", sep = ""),
#   width=150, height=90, units="mm", dpi = 300)

```


```{r}

canopy_min <- min(buffalo_CLR_year_harmonics$canopy_cover)
canopy_max <- max(buffalo_CLR_year_harmonics$canopy_cover)
canopy_seq <- seq(canopy_min, canopy_max, by = 1)

# Create empty data frame
canopy_fresponse_df <- data.frame(matrix(ncol = nrow(harmonics_df_mean), nrow = length(canopy_seq)))
for(i in 1:nrow(harmonics_df_mean)) {
  # Assign the vector as a column to the dataframe
  canopy_fresponse_df[,i] <- (harmonics_df_mean$canopy[i] * canopy_seq) + (harmonics_df_mean$canopy_2[i] * (canopy_seq ^ 2))
}

canopy_fresponse_df <- data.frame(canopy_seq, canopy_fresponse_df)
colnames(canopy_fresponse_df) <- c("canopy", yday)
canopy_fresponse_long <- pivot_longer(canopy_fresponse_df, cols = !1, names_to = "yday")

max(canopy_fresponse_long$value) # 0.2389213

canopy_natural <- ggplot(data = canopy_fresponse_long, aes(x = as.numeric(yday), y = canopy)) +
  geom_point(aes(colour = value)) +
  geom_contour(aes(z = value), breaks = seq(0, 1.75, 0.0625), colour = "black", linewidth = 0.25, linetype = "dashed") +
  geom_contour(aes(z = value), breaks = seq(-0, -5, -0.0625), colour = "red", linewidth = 0.25, linetype = "dashed") +
  geom_contour(aes(z = value), breaks = 0, colour = "black", linewidth = 0.5) +
  geom_vline(xintercept = 121, alpha = 0.25) +
  geom_vline(xintercept = 304, alpha = 0.25) +
  scale_x_continuous("Day of the year") +
  scale_y_continuous(expression("Canopy cover (%)"), breaks = seq(0, 100, 25)) +
  scale_colour_viridis_c("Selection") +
  # ggtitle("Canopy cover") +
  theme_classic()

canopy_natural

# ggsave(paste("outputs/plots/clr_fitting/clr_lasso_canopy_quad_20230622.png", sep = ""),
#   width=150, height=90, units="mm", dpi = 300)

```



```{r}

herby_min <- min(buffalo_CLR_year_harmonics$veg_herby)
herby_max <- max(buffalo_CLR_year_harmonics$veg_herby)
herby_seq <- seq(herby_min, herby_max, by = 0.01)

# Create empty data frame
herby_fresponse_df <- data.frame(matrix(ncol = nrow(harmonics_df_mean), nrow = length(herby_seq)))
for(i in 1:nrow(harmonics_df_mean)) {
  # Assign the vector as a column to the dataframe
  herby_fresponse_df[,i] <- (harmonics_df_mean$herby[i] * herby_seq)
}

herby_fresponse_df <- data.frame(herby_seq, herby_fresponse_df)
colnames(herby_fresponse_df) <- c("herby", yday)
herby_fresponse_long <- pivot_longer(herby_fresponse_df, cols = !1, names_to = "yday")

max(herby_fresponse_long$value) # 0.1259495

herby_natural <- ggplot(data = herby_fresponse_long, aes(x = as.numeric(yday), y = herby)) +
  geom_point(aes(colour = value)) +
  geom_contour(aes(z = value), breaks = seq(0, 1.75, 0.0625), colour = "black", linewidth = 0.25, linetype = "dashed") +
  geom_contour(aes(z = value), breaks = seq(-0, -5, -0.0625), colour = "red", linewidth = 0.25, linetype = "dashed") +
  geom_contour(aes(z = value), breaks = 0, colour = "black", linewidth = 0.5) +
  scale_x_continuous("Day of the year") +
  scale_y_continuous("Herbaceous vegtation", breaks = c(0, 1)) +
  scale_colour_viridis_c("Selection") +
  ggtitle("Herbaceous vegtation") +
  theme_classic()

herby_natural

```

Adding plots together

```{r}

ggarrange(ndvi_natural + theme(axis.title.x = element_blank()), 
          elev_natural + theme(axis.title.x = element_blank()), 
          canopy_natural, 
          herby_plot,
          ncol = 2,
          nrow = 2,
          align = "v",
          common.legend = TRUE,
          legend = "bottom"
          )

ggsave(paste("outputs/plots/clr_fitting/clr_lasso_avg_arrange_natural_scale_herby_20230724.png", sep = ""),
  width=150, height=130, units="mm", dpi = 300)

```


```{r}

# coefs <- unique(yday_coefs_long$coef)
# coef_titles <- c("NDVI", "Slope", "Herbaceous vegetation", "Canopy cover", "Step length", "log(Step length)", "cos(Turning angle)")

external_selection_parameters_plot <- ggplot() +
  geom_path(data = harmonics_df_long_scaled %>%
              filter(id == "mean" & name %in% unique(harmonics_df_long_scaled$name)[1:7]),
            aes(x = yday, y = value, colour = name)) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  geom_vline(xintercept = 121, alpha = 0.25) +
  geom_vline(xintercept = 304, alpha = 0.25) +
  scale_y_continuous(expression(Parameter~values)) +
  scale_x_continuous("Day of the year") +
  scale_color_viridis_d("",
                        labels = c(
                          expression("Canopy cover"),
                          expression("Canopy cover"^2),
                          expression(Elevation),
                          expression(Elevation^2),
                          expression("Herbaceous vegetation"),
                          expression(NDVI),  # Symbolic label using the expression function
                          expression(NDVI^2))) +
  # ggtitle("External selection parameters") +
  theme_classic() +
  theme(legend.position = "right", legend.text.align = 0)

external_selection_parameters_plot

# ggsave(paste("outputs/plots/clr_fitting/clr_lasso_avg_habitat_20230620.png", sep = ""),
#   width=150, height=90, units="mm", dpi = 300)
# ggsave(paste("outputs/plots/clr_fitting/clr_harmonic_all_pres_20230208.png", sep = ""),
#   width=300, height=180, units="mm", dpi = 300)

herby_plot <- ggplot() +
  geom_path(data = harmonics_df_long_nat %>%
              filter(id == "mean" & name %in% unique(harmonics_df_long_nat$name)[7]),
            aes(x = yday, y = value, colour = name)) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  geom_vline(xintercept = 121, alpha = 0.25) +
  geom_vline(xintercept = 304, alpha = 0.25) +
  scale_y_continuous(expression(Parameter~value), limits = c(-0.2, 0.2)) +
  scale_x_continuous("Day of the year") +
  scale_color_viridis_d("",
                        labels = "Herbaceous vegetation") +
  # ggtitle("External selection parameters") +
  theme_classic() +
  theme(legend.position = "right", legend.text.align = 0)

herby_plot

ggplot() +
  geom_path(data = harmonics_df_long_scaled %>%
              filter(id == "mean" & name %in% unique(harmonics_df_long_scaled$name)[8:10]),
            aes(x = yday, y = value, colour = name)) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  scale_y_continuous(expression(Parameter~values~beta)) +
  scale_x_continuous("Day of the year") +
  scale_color_viridis_d("",
                        labels = c(
                          expression(cos("Turning angle")),
                          expression("Step length "[log]),
                          expression("Step length")
                          )) +
  # scale_color_discrete("Estimate") +
  ggtitle("Movement parameters") +
  theme_classic() +
  theme(legend.position = "right")

```

Movement parameters

```{r}

# for individuals
# movement_parameters <- read_csv("outputs/buffalo_parametric_indv_movement_params_20230208.csv")
# movement_parameters_year <- movement_parameters %>% filter(id %in% buffalo_year_ids)

# for the population
# gamma$params$shape # 0.438167
# gamma$params$scale # 534.3507
# vonmises$params$kappa # 0.1848126

tentative_shape <- 0.438167
tentative_scale <- 534.3507
tentative_kappa <- 0.1848126

yday_coefs <- harmonics_df_all_nat %>% filter(id == "mean") %>% mutate(shape = tentative_shape + log_sl,
                             scale = 1/((1/tentative_scale) - sl),
                             kappa = tentative_kappa + cos_ta,
                             id = NULL) 

# write_csv(harmonic_coefs_df, "outputs/harmonic_coefs_df_with_movement_params_ndvi_canopy_quads_20230519.csv")

# turning into a long data frame
yday_coefs_long <- pivot_longer(yday_coefs, cols = !1, names_to = "coef")
yday_coefs_long

# write_csv(harmonic_coefs, "outputs/harmonic_coefs_df_long_with_movement_params_ndvi_canopy_quads_20230519.csv")

```

Movement parameters back on their natural scale

```{r}

movement_params_plot <- ggplot() +
  geom_path(data = yday_coefs_long %>% 
              filter(coef %in% unique(yday_coefs_long$coef)[c(11,13)]), 
            aes(x = yday, y = value, colour = coef)) +
    geom_path(data = yday_coefs_long %>% 
              filter(coef %in% unique(yday_coefs_long$coef)[c(12)]), 
            aes(x = yday, y = value/600, colour = coef)) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  geom_vline(xintercept = 121, alpha = 0.25) +
  geom_vline(xintercept = 304, alpha = 0.25) +
  scale_y_continuous(expression(Parameter~values)) +
  scale_x_continuous("Day of the year") +
  scale_color_viridis_d("",
                        labels = c(
                          expression("kappa (von Mises)"),
                          expression("scale (Gamma) / 600"),
                          expression("shape (Gamma)"))) +
  # scale_color_discrete("Estimate") +
  # ggtitle("Movement parameters") +
  theme_classic() +
  theme(legend.position = "right")

movement_params_plot

# ggsave(paste("outputs/plots/clr_fitting/clr_lasso_avg_movement_20230620.png", sep = ""),
#   width=150, height=90, units="mm", dpi = 300)
# ggsave(paste("outputs/plots/clr_fitting/clr_harmonic_all_pres_20230208.png", sep = ""),
#   width=300, height=180, units="mm", dpi = 300)

```

Combining plots

```{r}

ggarrange(external_selection_parameters_plot + theme(axis.title.x = element_blank()), movement_params_plot,
          nrow = 2,
          align = "v",
          labels = "AUTO")

ggsave(paste("outputs/plots/clr_fitting/clr_lasso_avg_movement_and_selection_20230724.png", sep = ""),
  width=150, height=120, units="mm", dpi = 300)
# ggsave(paste("outputs/plots/clr_fitting/clr_harmonic_all_pres_20230208.png", sep = ""),
#   width=300, height=180, units="mm", dpi = 300)

```



```{r temporal naive}

years <- c(rep(2019, 7), rep(2018, 5))
months <- c(seq(1, 7, 1), seq(8, 12, 1))
day <- rep(1, 12)
dates <- make_datetime(year = years, month = months, day = day, tz = "Australia/Queensland")

mid_month <- c(16, 47, 75, 106, 136, 167, 197, 228, 259, 289, 320, 350)

# get the coefficient at the middle of each month (15th day)
monthly_coefs <- data.frame("date" = dates,
                         "ndvi" = yday_coefs$ndvi[mid_month],
                         "ndvi_quad" = yday_coefs$ndvi_2[mid_month],
                         "canopy" = yday_coefs$canopy[mid_month],
                         "canopy_quad" = yday_coefs$canopy_2[mid_month],
                         "herby" = yday_coefs$herby[mid_month],
                         "elev" = yday_coefs$elev[mid_month],
                         "elev_quad" = yday_coefs$elev_2[mid_month],
                         "shape" = yday_coefs$shape[mid_month],
                         "scale" = yday_coefs$scale[mid_month],
                         "kappa" = yday_coefs$kappa[mid_month])

# write_csv(monthly_coefs, "outputs/monthly_coefs_wide_yday_with_movement_params_20230530.csv") 

monthly_coefs_long <- monthly_coefs %>% pivot_longer(cols = !date)

# sanity check to ensure that the coefficients line up to the correct months
monthly_coefs_long %>% filter(!name %in% c("shape", "scale", "kappa")) %>% 
  ggplot(aes(x = month(date), y = value, colour = factor(name))) +
  geom_line() +
  scale_colour_viridis_d("Covariate") +
  geom_hline(yintercept = 0, linetype = "dashed") +
  scale_x_continuous(breaks = 1:12) +
  theme_classic()

```

# Predictions and cross-validation

## Naive prediction approach

```{r}

boyce_naive_list <- vector(mode = "list", length = 12)
naive_pred_stack <- c()
naive_norm_stack <- c()

tic()

for(i in 1:12) {

  # with scaled parameters
# resources <- c(ndvi_stack_scaled_cropped[[which(time(ndvi_stack_scaled_cropped) == monthly_coefs$date[i])]], 
#                canopy_scaled_cropped,
#                herby_scaled_cropped
#                # elev_scaled_cropped
#                )

# with natural scaled parameters
resources <- c(ndvi_stack_cropped[[which(time(ndvi_stack_cropped) == monthly_coefs$date[i])]], 
               canopy_cropped,
               herby_cropped,
               elev_log_cropped
               )

# ndvi
ndvi_lin <- resources[[1]]
ndvi_lin <- ndvi_lin * monthly_coefs$ndvi[[i]]
# plot(ndvi_lin)
ndvi_quad <- resources[[1]]
ndvi_quad <- (ndvi_quad ^ 2) * monthly_coefs$ndvi_quad[[i]] 
# plot(ndvi_quad)
ndvi_pred <- ndvi_lin + ndvi_quad
# plot(ndvi_pred)

# canopy cover 
canopy_lin <- resources[[2]]
canopy_lin <- canopy_lin * monthly_coefs$canopy[[i]]
# plot(canopy_lin)
canopy_quad <- resources[[2]]
canopy_quad <- (canopy_quad ^ 2) * monthly_coefs$canopy_quad[[i]] 
# plot(canopy_quad)
canopy_pred <- canopy_lin + canopy_quad
# plot(canopy_pred)

# herby
herby_lin <- resources[[3]]
herby_pred <- herby_lin * monthly_coefs$herby[[i]] 
# plot(herby_pred)

# elev
elev_lin <- resources[[4]]
elev_lin <- elev_lin * monthly_coefs$elev[[i]]
# plot(elev_pred)
elev_quad <- resources[[4]]
elev_quad <- (elev_quad ^ 2) * monthly_coefs$elev_quad[[i]]
# plot(elev_quad)
elev_pred <- elev_lin + elev_quad
# plot(elev_pred)

# combining
naive_pred <- exp(ndvi_pred + 
                    canopy_pred + 
                    herby_pred + 
                    elev_pred
                  )

naive_norm <- naive_pred / global(naive_pred, fun = "sum", na.rm = TRUE)[[1]]

plot(naive_norm)
points(as.numeric(buffalo_CLR_year %>% filter(y == 1 & month == i) %>% dplyr::select(x1) %>% unlist()), 
       as.numeric(buffalo_CLR_year %>% filter(y == 1 & month == i) %>% dplyr::select(y1) %>% unlist()))

naive_pred_stack <- c(naive_pred_stack, naive_pred)
naive_norm_stack <- c(naive_norm_stack, naive_norm)

# setting up the buffalo observation data for the relevant month
buffalo_obs <- buffalo_CLR_year_harmonics %>% filter(y == 1 & month == i) %>% 
  transmute(x = x1 - xmin, y = y1 - ymin)

naive_raster <- raster(naive_norm)

boyce_naive_list[[i]] <- ecospat.boyce2(naive_raster, buffalo_obs,
                              # method = "pearson"
                              method = "pearson",
                              # method = "kendall"
                              )

boyce_naive_list[[i]]

}

toc()

naive_pred_lasso <- naive_pred_stack
naive_norm_lasso <- naive_norm_stack
boyce_naive_list_lasso <- boyce_naive_list

beep(sound = 2)

```



```{r}

for(i in 1:12) {
  plot(naive_pred_stack[[i]])
}

for(i in 1:12) {
  # plot(naive_pred_stack[[i]])
  plot(naive_pred_stack[[i]])
  points(as.numeric(buffalo_CLR_year %>% filter(y == 1 & month == i) %>% dplyr::select(x1) %>% unlist()) - xmin, 
       as.numeric(buffalo_CLR_year %>% filter(y == 1 & month == i) %>% dplyr::select(y1) %>% unlist()) - ymin)
}

```


```{r}

pearson_cor <- c()

for(i in 1:12) {
  print(boyce_naive_list[[i]]$cor)
  pearson_cor[i] <- boyce_naive_list[[i]]$cor
}

mean(pearson_cor)
sd(pearson_cor)

```

Isolating the predictions for a single individual

```{r}

# creating empty variables
boyce_naive_id_month_list <- vector(mode = "list", length = 12)
boyce_naive_id_month_list_list <- vector(mode = "list", length = 10)
pearson_cor_id_month <- vector(mode = "numeric", length = 12)
pearson_cor_id_month_list <- vector(mode = "list", length = 10)

# creating the necessary objects
naive_norm_lasso_stack <- rast(naive_norm_lasso)
ext(naive_norm_lasso_stack) <- orig_extent
id_list <- unique(buffalo_CLR_year_harmonics$id)

# outer loop for each individual
for(j in 1:length(unique(buffalo_CLR_year_harmonics$id))) {

  # j <- 1
  
  buffalo_id_data <- buffalo_CLR_year_harmonics %>% dplyr::filter(id == id_list[j])
  
  xmin <- round(min(buffalo_id_data$x2), digits = -2)
  xmax <- round(max(buffalo_id_data$x2), digits = -2)
  ymin <- round(min(buffalo_id_data$y2), digits = -2)
  ymax <- round(max(buffalo_id_data$y2), digits = -2)
  
  crop_extent <- ext(xmin, xmax, ymin, ymax)
  naive_norm_lasso_stack_id <- terra::crop(naive_norm_lasso_stack, crop_extent)
  
  # inner loop for months over each individual
  for(i in 1:nlyr(naive_norm_lasso_stack_id)) {
  
    # i <- 1
    
    naive_rast_monthly <- raster(naive_norm_lasso_stack_id[[i]])
    # setting up the buffalo observation data for the relevant month
    buffalo_obs <- buffalo_CLR_year_harmonics %>% dplyr::filter(id == id_list[j] & y == 1 & month == i) %>% 
      transmute(x = x1, y = y1)
    # plot(naive_rast_monthly)
    # points(buffalo_obs$x, buffalo_obs$y)
    
    boyce_naive_id_month_list[[i]] <- ecospat.boyce2(naive_rast_monthly, buffalo_obs,
                                  # method = "spearman"
                                  method = "pearson",
                                  # method = "kendall"
                                  )
    
    pearson_cor_id_month[i] <- boyce_naive_id_month_list[[i]]$cor
    
  }
  
  boyce_naive_id_month_list_list[[j]] <- boyce_naive_id_month_list
  pearson_cor_id_month_list[[j]] <- data.frame("id" = id_list[j], "month" = 1:12, "pearson_cor" = pearson_cor_id_month)
  
}


```

```{r}

pearson_cor_all_ids <- bind_rows(pearson_cor_id_month_list)

ggplot() +
  geom_boxplot(data = pearson_cor_all_ids, aes(x = factor(month), y = pearson_cor), alpha = 0.5, outlier.shape = NA) +
  geom_jitter(data = pearson_cor_all_ids, aes(x = factor(month), y = pearson_cor), alpha = 0.5, width = 0.1) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  geom_hline(yintercept = -1, linetype = "longdash") +
  geom_hline(yintercept = 1, linetype = "longdash") +
  scale_y_continuous("Pearson's correlation coefficient", limits = c(-1,1)) +
  theme_classic()

```

Combining with the static estimate

```{r}

pearson_cor_all_ids_dynamic <- spearman_cor_all_ids
pearson_cor_all_ids_static <- read_csv("outputs/pearson_cor_lasso_avg_static_20230724.csv")

pearson_cor_all_ids_dynamic$method <- "dynamic"
pearson_cor_all_ids_dynamic$pearson_cor <- pearson_cor_all_ids_dynamic$spearman_cor
pearson_cor_all_ids_dynamic$spearman_cor <- NULL

pearson_cor_all_ids_static$method <- "static"

pearson_cor_all_ids_both <- bind_rows(pearson_cor_all_ids_dynamic, pearson_cor_all_ids_static)
pearson_cor_all_ids_both %>% dplyr::group_by(method) %>% summarise(mean = mean(pearson_cor))

ggplot() +
  geom_boxplot(data = pearson_cor_all_ids_both, aes(x = factor(month), y = pearson_cor, colour = method), alpha = 0.5, outlier.shape = NA) +
  geom_jitter(data = pearson_cor_all_ids_both, aes(x = factor(month), y = pearson_cor, colour = method), alpha = 0.5, width = 0.1) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  geom_hline(yintercept = -1, linetype = "longdash") +
  geom_hline(yintercept = 1, linetype = "longdash") +
  scale_y_continuous("Pearson's correlation coefficient", limits = c(-1,1)) +
  theme_classic()

ggsave(paste0("outputs/plots/clr_fitting/clr_lasso_avg_arrange_predictions_20230724.png"),
  width=150, height=130, units="mm", dpi = 300)

```

Outputting a few months for the manuscript

```{r}

for(i in 1:12) plot(naive_norm_lasso[[i]])
plot(naive_norm_lasso[[3]])
plot(naive_norm_lasso[[6]])
plot(naive_norm_lasso[[9]])

naive_norm_lasso_3 <- as.data.frame(naive_norm_lasso[[3]], xy = TRUE)
naive_norm_lasso_6 <- as.data.frame(naive_norm_lasso[[6]], xy = TRUE)
naive_norm_lasso_9 <- as.data.frame(naive_norm_lasso[[9]], xy = TRUE)

```

Plotting

```{r}

naive_plot_3 <- ggplot() +
  geom_raster(data = naive_norm_lasso_3, 
              aes(x = x, y = y, fill = naive_norm_lasso_3[,3])) +
  scale_fill_viridis_c("Habitat suitability", direction = 1) + 
  coord_equal() +
  ggtitle(paste0("March")) +
  theme_classic() +
  theme(legend.position = "none", legend.key.width = unit(1, "cm"), axis.text = element_blank())

naive_plot_3


naive_plot_6 <- ggplot() +
  geom_raster(data = naive_norm_lasso_6, 
              aes(x = x, y = y, fill = naive_norm_lasso_6[,3])) +
  scale_fill_viridis_c("Habitat suitability", direction = 1) + 
  coord_equal() +
  ggtitle(paste0("June")) +
  theme_classic() +
  theme(legend.position = "none", legend.key.width = unit(1, "cm"), axis.text = element_blank())

naive_plot_6


naive_plot_9 <- ggplot() +
  geom_raster(data = naive_norm_lasso_9, 
              aes(x = x, y = y, fill = naive_norm_lasso_9[,3])) + 
  scale_fill_viridis_c("Habitat suitability", direction = 1) +
  coord_equal() +
  ggtitle(paste0("September")) +
  theme_classic() +
  theme(legend.position = "none", legend.key.width = unit(1, "cm"), axis.text = element_blank())

naive_plot_9

# ggsave(filename = "outputs/plots/hourly_preds/lasso daily/MCBM_daily_wpoints_hour_11_20230710.png", width=180, height=100, units="mm", dpi = 300)

```

Replotting for more specific plot

```{r}

external_selection_parameters_plot2 <- ggplot() +
  geom_path(data = harmonics_df_long_scaled %>%
              filter(id == "mean" & name %in% unique(harmonics_df_long_scaled$name)[1:7]),
            aes(x = yday, y = value, colour = name)) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  geom_vline(xintercept = 74, linetype = "dashed") +
  geom_vline(xintercept = 166, linetype = "dashed") +
  geom_vline(xintercept = 258, linetype = "dashed") +
  scale_y_continuous(expression(Parameter~values)) +
  scale_x_continuous("Day of the year") +
  scale_color_viridis_d("",
                        labels = c(
                          expression("Canopy cover"),
                          expression("Canopy cover"^2),
                          expression(Elevation),
                          expression(Elevation^2),
                          expression("Herbaceous vegetation"),
                          expression(NDVI),  # Symbolic label using the expression function
                          expression(NDVI^2))) +
  # ggtitle("External selection parameters") +
  theme_classic() +
  theme(legend.position = "none", legend.text.align = 0)

external_selection_parameters_plot2

```


```{r}

pred_arranged <- ggarrange(external_selection_parameters_plot2, 
                           naive_plot_3, 
                           naive_plot_6,
                            naive_plot_9, 
                            ncol = 2,
                            # common.legend = TRUE,
                            legend = "none", 
                            nrow = 2,
                            align = "hv")

pred_arranged

ggsave(paste0("outputs/plots/clr_fitting/clr_lasso_avg_arrange_predictions_20230724.png"),
  width=150, height=130, units="mm", dpi = 300)

```


# Using the Barnett-Moorcroft approximation prediction approach with Monte Carlo approximation

Here we use the Barnett-Moorcroft approximation to estimate the UD, sampling from the movement kernel to approximate the integral in the numerator of:

BM equation

```{r}

naive_preds <- rast(naive_pred_stack)

Beta_Z_z_list  <- vector(mode = "list", length = 12)
MCBM_preds_list <- vector(mode = "list", length = 12)

n_proposals <- 10
grid_res <- terra::res(naive_preds)[1]
rows <- terra::nrow(naive_preds)
cols <- terra::ncol(naive_preds)
xmax <- ext(naive_preds[[1]])[2] 
ymax <- ext(naive_preds[[1]])[4]

for(month_no in 1:12) {
  
  # for testing the loop
  # month_no <- 9

tic()

# Create grid of x and y points
x_points <- rep(1:cols, each = rows)
y_points <- rep(1:rows, times = cols)

# Generate random angles and lengths
ta <- runif(n_proposals * length(x_points), min = -pi, max = pi)
sl <- rgamma(n_proposals * length(x_points), shape = monthly_coefs$shape[month_no], scale = monthly_coefs$scale[month_no])

# Calculate proposal points
x_proposal <- ((-(grid_res/2) + x_points * grid_res) + sl * sin(ta)) %% xmax
y_proposal <- ((-(grid_res/2) + y_points * grid_res) + sl * cos(ta)) %% ymax

# exp(beta * Z(x))
# plot(naive_ud_cropped[[i]])

# exp(beta * Z(z)) * psi(.) dz
Beta_Z_z_proposed <- terra::extract(naive_preds[[month_no]], cbind(x_proposal, y_proposal))[,1]
Beta_Z_z_array <- array(Beta_Z_z_proposed, dim = c(rows, cols , n_proposals))
Beta_Z_z_matrix <- apply(Beta_Z_z_array, 1:2, mean, na.rm = TRUE)

toc()

Beta_Z_z_list[[month_no]] <- flip(terra::setValues(naive_preds[[month_no]], Beta_Z_z_matrix))
# plot(naive_ud_cropped[[i]])
# plot(Beta_Z_z_list[[month_no]])

# exp(beta * Z(x)) * exp(beta * Z(z)) * psi(.) dz
u_x_unnorm <- naive_preds[[month_no]] * Beta_Z_z_list[[month_no]]
# plot(u_x_unnorm)
u_x <- u_x_unnorm / as.numeric(terra::global(u_x_unnorm, fun = "sum", na.rm = TRUE))
names(u_x) <- paste0("MCBM_month_", month_no)
plot(u_x)

MCBM_preds_list[[month_no]] <- u_x

}

MCBM_preds_lasso_monthly <- rast(MCBM_preds_list)
writeRaster(MCBM_preds_lasso_monthly, "outputs/rasters/MCBM_preds_lasso_monthly_20230724.tif")

```

Save MC-BM preds as a different object to run a different model

```{r}

# MCBM_preds_list_lasso_elev2 <- MCBM_preds_list

```

Plotting

```{r}

for(month_no in 1:12) {

# exp(beta * Z(x))
plot(naive_pred_stack[[month_no]])
# plot(naive_pred_stack[[month_no]])
# points(as.numeric(buffalo_CLR_year %>% 
#                     filter(y == 1 & month == month_no) %>% 
#                     dplyr::select(x1) %>% unlist()) - xmin, 
#        as.numeric(buffalo_CLR_year %>% 
#                     filter(y == 1 & month == month_no) %>% 
#                     dplyr::select(y1) %>% unlist()) - ymin)

# exp(beta * Z(z)) * psi(.) dz
plot(Beta_Z_z_list[[month_no]])

# exp(beta * Z(x)) * exp(beta * Z(z)) * psi(.) dz
plot(MCBM_preds_list[[month_no]])
# plot(MCBM_preds_list[[month_no]])
# points(as.numeric(buffalo_CLR_year %>%
#                     filter(y == 1 & month == month_no) %>%
#                     dplyr::select(x1) %>% unlist()) - xmin,
#        as.numeric(buffalo_CLR_year %>%
#                     filter(y == 1 & month == month_no) %>%
#                     dplyr::select(y1) %>% unlist()) - ymin)

}

for(month_no in 1:12) {

# exp(beta * Z(x)) * exp(beta * Z(z)) * psi(.) dz
# plot(MCBM_preds_list[[month_no]])
plot(MCBM_preds_list[[month_no]])
points(as.numeric(buffalo_CLR_year %>%
                    filter(y == 1 & month == month_no) %>%
                    dplyr::select(x1) %>% unlist()) - xmin,
       as.numeric(buffalo_CLR_year %>%
                    filter(y == 1 & month == month_no) %>%
                    dplyr::select(y1) %>% unlist()) - ymin)

}

```


```{r}

for(month_no in 1:12) {

# exp(beta * Z(x)) * exp(beta * Z(z)) * psi(.) dz
# plot(MCBM_preds_list[[month_no]])
plot(MCBM_preds_list[[month_no]])
# points(as.numeric(buffalo_CLR_year %>%
#                     filter(y == 1 & month == month_no) %>%
#                     dplyr::select(x1) %>% unlist()) - xmin,
#        as.numeric(buffalo_CLR_year %>%
#                     filter(y == 1 & month == month_no) %>%
#                     dplyr::select(y1) %>% unlist()) - ymin)

}

```

Outputting a few months for the manuscript

```{r}

for(i in 1:12) plot(MCBM_preds_list[[i]])
plot(MCBM_preds_list[[3]])
plot(MCBM_preds_list[[6]])
plot(MCBM_preds_list[[9]])

MCBM_lasso_3 <- as.data.frame(MCBM_preds_list[[3]], xy = TRUE)
MCBM_lasso_6 <- as.data.frame(MCBM_preds_list[[6]], xy = TRUE)
MCBM_lasso_9 <- as.data.frame(MCBM_preds_list[[9]], xy = TRUE)

```

Plotting

```{r}

MCBM_lasso_plot_3 <- ggplot() +
  geom_raster(data = MCBM_lasso_3, 
              aes(x = x, y = y, fill = MCBM_lasso_3[,3])) +
  scale_fill_viridis_c("Habitat suitability", direction = 1) + 
  # geom_point(data = buffalo_CLR_year_harmonics %>% filter(month == 3 & y == 1), 
  #            aes(x = x1 - xmin, y = y2 - ymin), alpha = 0.5, colour = "red", size = 0.25) +
  coord_equal() +
  # ggtitle(paste0("March")) +
  scale_x_continuous("Easting (m)") +
  scale_y_continuous("Northing (m)") +
  theme_classic() +
  theme(legend.position = "none", legend.key.width = unit(1, "cm")) # , axis.text = element_blank()

MCBM_lasso_plot_3
ggsave(filename = "outputs/plots/CLR_fitting/MCBM_monthly_3_20230725.png", width=100, height=100, units="mm", dpi = 300)


MCBM_lasso_plot_6 <- ggplot() +
  geom_raster(data = MCBM_lasso_6, 
              aes(x = x, y = y, fill = MCBM_lasso_6[,3])) +
  # geom_point(data = buffalo_CLR_year_harmonics %>% filter(month == 6 & y == 1), 
  #            aes(x = x1 - xmin, y = y2 - ymin), alpha = 0.5, colour = "red", size = 0.25) +
  scale_fill_viridis_c("Habitat suitability", direction = 1) + 
  coord_equal() +
  # ggtitle(paste0("June")) +
  scale_x_continuous("Easting (m)") +
  scale_y_continuous("Northing (m)") +
  theme_classic() +
  theme(legend.position = "none", legend.key.width = unit(1, "cm")) # , axis.text = element_blank()

MCBM_lasso_plot_6
ggsave(filename = "outputs/plots/CLR_fitting/MCBM_monthly_6_20230725.png", width=100, height=100, units="mm", dpi = 300)


MCBM_lasso_plot_9 <- ggplot() +
  geom_raster(data = MCBM_lasso_9, 
              aes(x = x, y = y, fill = MCBM_lasso_9[,3])) + 
  # geom_point(data = buffalo_CLR_year_harmonics %>% filter(month == 9 & y == 1), 
  #            aes(x = x1 - xmin, y = y2 - ymin), alpha = 0.5, colour = "red", size = 0.25) +
  scale_fill_viridis_c("Habitat suitability", direction = 1) +
  coord_equal() +
  # ggtitle(paste0("September")) +
  scale_x_continuous("Easting (m)") +
  scale_y_continuous("Northing (m)") +
  theme_classic() +
  theme(legend.position = "none", legend.key.width = unit(1, "cm")) # , axis.text = element_blank()

MCBM_lasso_plot_9
ggsave(filename = "outputs/plots/CLR_fitting/MCBM_monthly_9_20230725.png", width=100, height=100, units="mm", dpi = 300)

```

Replotting for more specific plot

```{r}

external_selection_parameters_plot <- ggplot() +
  geom_path(data = harmonics_df_long_scaled %>%
              filter(id == "mean" & name %in% unique(harmonics_df_long_scaled$name)[1:7]),
            aes(x = yday, y = value, colour = name)) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  geom_vline(xintercept = 74, linetype = "dashed") +
  geom_vline(xintercept = 166, linetype = "dashed") +
  geom_vline(xintercept = 258, linetype = "dashed") +
  scale_y_continuous(expression(Parameter~values)) +
  scale_x_continuous("Day of the year") +
  scale_color_viridis_d("",
                        labels = c(
                          expression("Canopy cover"),
                          expression("Canopy cover"^2),
                          expression(Elevation),
                          expression(Elevation^2),
                          expression("Herbaceous vegetation"),
                          expression(NDVI),  # Symbolic label using the expression function
                          expression(NDVI^2))) +
  # ggtitle("External selection parameters") +
  theme_classic() +
  theme(legend.position = "none", legend.text.align = 0)

external_selection_parameters_plot
ggsave(filename = "outputs/plots/CLR_fitting/CLR_lasso_coefs_no_annotation_20230725.png", width=100, height=100, units="mm", dpi = 300)

```


```{r}

pred_arranged <- ggarrange(external_selection_parameters_plot, 
                           MCBM_lasso_plot_3 + theme(axis.text = element_blank()), 
                           MCBM_lasso_plot_6 + theme(axis.text = element_blank()),
                            MCBM_lasso_plot_9 + theme(axis.text = element_blank()), 
                            ncol = 2,
                           labels = "AUTO",
                            # common.legend = TRUE,
                            legend = "none", 
                            nrow = 2,
                            align = "hv")

pred_arranged

ggsave(paste0("outputs/plots/clr_fitting/clr_lasso_avg_arrange_predictions_20230724.png"),
  width=150, height=130, units="mm", dpi = 300)

```

Boyce index 

```{r}

xmin <- round(min(buffalo_CLR_year_harmonics$x2), digits = -2)
xmax <- round(max(buffalo_CLR_year_harmonics$x2), digits = -2)
ymin <- round(min(buffalo_CLR_year_harmonics$y2), digits = -2)
ymax <- round(max(buffalo_CLR_year_harmonics$y2), digits = -2)

boyce_naive_list <- vector(mode = "list", length = 12)
boyce_MCBM_list <- vector(mode = "list", length = 12)

for(month_no in 1:12) {

buffalo_obs <- buffalo_CLR_year_harmonics %>% 
  filter(y == 1 & month == month_no) %>% 
  transmute(x = x1 - xmin, y = y1 - ymin)

naive_raster <- raster(naive_norm_stack[[month_no]])
# boyce_naive_list[[month_no]] <- ecospat.boyce2(naive_raster, buffalo_obs, method = "spearman")
boyce_naive_list[[month_no]] <- ecospat.boyce2(naive_raster, buffalo_obs, method = "pearson")

}

for(month_no in 1:12) {

buffalo_obs <- buffalo_CLR_year_harmonics %>% 
  filter(y == 1 & month == month_no) %>% 
  transmute(x = x1 - xmin, y = y1 - ymin)

MCBM_raster <- raster(MCBM_preds_list[[month_no]])
# boyce_MCBM_list[[month_no]] <- ecospat.boyce2(MCBM_raster, buffalo_obs, method = "spearman")
boyce_MCBM_list[[month_no]] <- ecospat.boyce2(MCBM_raster, buffalo_obs, method = "pearson")

}

```

```{r}

pearson_cor_naive <- c()
pearson_cor_MCBM <- c()

for(i in 1:12) {
  
  # print(boyce_naive_list[[i]]$cor)
  # pearson_cor_naive[i] <- boyce_naive_list[[i]]$cor

  print(boyce_MCBM_list[[i]]$cor)
  pearson_cor_MCBM[i] <- boyce_MCBM_list[[i]]$cor
  
}

# mean(pearson_cor_naive)
# sd(pearson_cor_naive)

mean(pearson_cor_MCBM)
sd(pearson_cor_MCBM)

```

Isolating the predictions for a single individual

```{r}

# creating empty variables
boyce_MCBM_id_month_list <- vector(mode = "list", length = 12)
boyce_MCBM_id_month_list_list <- vector(mode = "list", length = 10)
pearson_cor_MCBM_id_month <- vector(mode = "numeric", length = 12)
pearson_cor_MCBM_id_month_list <- vector(mode = "list", length = 10)

# creating the necessary objects
MCBM_stack <- rast(MCBM_preds_list)
ext(MCBM_stack) <- orig_extent
id_list <- unique(buffalo_CLR_year_harmonics$id)

# outer loop for each individual
for(j in 1:length(unique(buffalo_CLR_year_harmonics$id))) {

  # j <- 1
  
  buffalo_id_data <- buffalo_CLR_year_harmonics %>% dplyr::filter(id == id_list[j])
  
  xmin <- round(min(buffalo_id_data$x2), digits = -2)
  xmax <- round(max(buffalo_id_data$x2), digits = -2)
  ymin <- round(min(buffalo_id_data$y2), digits = -2)
  ymax <- round(max(buffalo_id_data$y2), digits = -2)
  
  crop_extent <- ext(xmin, xmax, ymin, ymax)
  MCBM_stack_id <- terra::crop(MCBM_stack, crop_extent)
  
  # inner loop for months over each individual
  for(i in 1:nlyr(MCBM_stack_id)) {
  
    # i <- 1
    
    MCBM_stack_id_monthly <- raster(MCBM_stack_id[[i]])
    # setting up the buffalo observation data for the relevant month
    buffalo_obs <- buffalo_CLR_year_harmonics %>% dplyr::filter(id == id_list[j] & y == 1 & month == i) %>% 
      transmute(x = x1, y = y1)
    # plot(naive_rast_monthly)
    # points(buffalo_obs$x, buffalo_obs$y)
    
    boyce_MCBM_id_month_list[[i]] <- ecospat.boyce2(MCBM_stack_id_monthly, buffalo_obs,
                                  # method = "spearman"
                                  method = "pearson",
                                  # method = "kendall"
                                  )
    
    pearson_cor_MCBM_id_month[i] <- boyce_MCBM_id_month_list[[i]]$cor
    
  }
  
  boyce_MCBM_id_month_list_list[[j]] <- boyce_MCBM_id_month_list
  pearson_cor_MCBM_id_month_list[[j]] <- data.frame("id" = id_list[j], "month" = 1:12, "pearson_cor" = pearson_cor_MCBM_id_month)
  
}


```

```{r}

pearson_cor_MCBM_all_ids <- bind_rows(pearson_cor_MCBM_id_month_list)

ggplot() +
  geom_boxplot(data = pearson_cor_MCBM_all_ids, aes(x = factor(month), y = pearson_cor), alpha = 0.5, outlier.shape = NA) +
  geom_jitter(data = pearson_cor_MCBM_all_ids, aes(x = factor(month), y = pearson_cor), alpha = 0.5, width = 0.1) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  geom_hline(yintercept = -1, linetype = "longdash") +
  geom_hline(yintercept = 1, linetype = "longdash") +
  scale_y_continuous("Pearson's correlation coefficient", limits = c(-1,1)) +
  theme_classic()

```

Combining with the static estimate

```{r}

pearson_cor_MCBM_all_ids_dynamic <- pearson_cor_MCBM_all_ids
pearson_cor_MCBM_all_ids_static <- read_csv("outputs/pearson_cor_lasso_avg_static_MCBM_20230726.csv")

pearson_cor_MCBM_all_ids_dynamic$method <- "dynamic"
pearson_cor_MCBM_all_ids_static$method <- "static"

pearson_cor_MCBM_all_ids_both <- bind_rows(pearson_cor_MCBM_all_ids_dynamic, pearson_cor_MCBM_all_ids_static)
pearson_cor_MCBM_all_ids_both %>% dplyr::group_by(method) %>% summarise(mean = mean(pearson_cor))

ggplot() +
  geom_boxplot(data = pearson_cor_MCBM_all_ids_both, aes(x = factor(month), y = pearson_cor, colour = method), alpha = 0.5, outlier.shape = NA) +
  geom_jitter(data = pearson_cor_MCBM_all_ids_both, aes(x = factor(month), y = pearson_cor, colour = method), alpha = 0.5, width = 0.1) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  geom_hline(yintercept = -1, linetype = "longdash") +
  geom_hline(yintercept = 1, linetype = "longdash") +
  scale_y_continuous("Pearson's correlation coefficient", limits = c(-1,1)) +
  theme_classic()

ggsave(paste0("outputs/plots/clr_fitting/clr_lasso_avg_arrange_predictions_20230724.png"),
  width=150, height=130, units="mm", dpi = 300)

```


```{r}

# full_model_2harms_ndvi2_canopy2_herby_naive_cor <- pearson_cor_naive
# mean(full_model_2harms_ndvi2_canopy2_herby_naive_cor)
# sd(full_model_2harms_ndvi2_canopy2_herby_naive_cor)
# 
# full_model_2harms_ndvi2_canopy2_herby_MCBM_cor <- pearson_cor_MCBM
# mean(full_model_2harms_ndvi2_canopy2_herby_MCBM_cor)
# sd(full_model_2harms_ndvi2_canopy2_herby_MCBM_cor)

full_model_2harms_ndvi2_canopy2_herby_elev2_naive_cor <- pearson_cor_naive
mean(full_model_2harms_ndvi2_canopy2_herby_elev2_naive_cor)
sd(full_model_2harms_ndvi2_canopy2_herby_elev2_naive_cor)

full_model_2harms_ndvi2_canopy2_herby_elev2_MCBM_cor <- pearson_cor_MCBM
mean(full_model_2harms_ndvi2_canopy2_herby_elev2_MCBM_cor)
sd(full_model_2harms_ndvi2_canopy2_herby_elev2_MCBM_cor)

```

```{r}

# save.image("workspace images/full_model_2harms_ndvi2_canopy2_herby.RData")
save.image("workspace images/lasso_avg_harmonics_20230620.RData")

# beep(sound = 2)

```

