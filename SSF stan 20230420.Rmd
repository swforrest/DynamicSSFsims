---
title: "SSF stan"
author: "Scott Forrest"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

update.packages(ask = FALSE, checkBuilt = TRUE)
```



```{r}
#message = FALSE

# devtools::install_github("jmsigner/amt")
# install.packages("amt")

library(tidyverse)

packages <- c("amt", "lubridate", "mgcv", "survival", "terra", "raster", "tictoc", "RColorBrewer", "patchwork", "ecospat", "ggmap", "basemaps", "mapedit", "sf", "rstan", "brms", "beepr")
walk(packages, require, character.only = T)

rstan_options(auto_write = TRUE)
options(mc.cores = parallel::detectCores())

```


Import buffalo telemetry data

```{r message = FALSE}

# buffalo_CLR <- read_csv(file = "outputs/buffalo_parametric_indv_covs_20230208.csv")
# using the population estimate as the TENTATIVE distribution will make it easier to estimate the weighted mean estimate of the movement kernel
buffalo_data <- read_csv(file = "outputs/buffalo_parametric_popn_covs_20230208.csv")

unique(buffalo_data$id)

# scaling_mean <- mean(values(ndvi_projected[[7]], na.rm = TRUE)) # 0.4054526 for July 2018
# scaling_sd <- sd(values(ndvi_projected[[7]], na.rm = TRUE)) # 0.1113644 for July 2018

buffalo_CLR <- buffalo_data %>% 
  mutate(id_num = as.numeric(factor(id)), 
         step_id = step_id_, 
         x1 = x1_, x2 = x2_, 
         y1 = y1_, y2 = y2_, 
         t1 = t1_, 
         t1_rounded = round_date(buffalo_data$t1_, "hour"), 
         t2 = t2_, 
         yday = yday(t1_),
         sl = sl_, log_sl = log_sl_, 
         ta = ta_, cos_ta = cos_ta_,
         year = year(t1_), 
         month = month(t1_), 
         # month_factor = factor(month(t1_)),
         hour = hour(t1_),
         # hour_factor = factor(hour),
         # day = day(t1_),
         # day_factor = factor(day(t1_)),
         # step_id_factor = factor(step_id_),
         ndvi_scaled = scale(ndvi_temporal),
         ndvi_scaled_raster = ((ndvi_temporal - 0.4054526) / 0.1113644),
         canopy_01 = canopy_cover/100,
         herby_scaled = scale(veg_herby),
         canopy_scaled = scale(canopy_01),
         elev_scaled = scale(DEM_H_end),
         elev_delta_scaled = scale(elev_delta),
         elev_log_scaled = scale(elev_log),
         slope_scaled = scale(slope_end),
         month_s1 = sin(2*pi*month/12),
         month_s2 = sin(4*pi*month/12),
         month_s3 = sin(6*pi*month/12),
         month_s4 = sin(8*pi*month/12),
         month_c1 = cos(2*pi*month/12),
         month_c2 = cos(4*pi*month/12),
         month_c3 = cos(6*pi*month/12),
         month_c4 = cos(8*pi*month/12),
         yday_s1 = sin(2*pi*yday/365),
         yday_s2 = sin(4*pi*yday/365),
         yday_s3 = sin(6*pi*yday/365),
         yday_s4 = sin(8*pi*yday/365),
         yday_c1 = cos(2*pi*yday/365),
         yday_c2 = cos(4*pi*yday/365),
         yday_c3 = cos(6*pi*yday/365),
         yday_c4 = cos(8*pi*yday/365)) %>%
  drop_na(c(ndvi_temporal, veg_herby, canopy_01, sl_)) %>% 
  dplyr::select(!(burst_:case_))

```

Filtering by animals that have more than a year of data

```{r}

buffalo_year_ids <- c(2005, 2014, 2018, 2022, 2024, 2154, 2158, 2327, 2354, 2387)
buffalo_CLR_year <- buffalo_CLR %>% filter(id %in% buffalo_year_ids)
unique(buffalo_CLR_year$id)

```



```{r}

hist(buffalo_CLR_year$ndvi_scaled) # this one should better in the regression, then apply this scaling to the rasters for prediction
attributes(buffalo_CLR_year$ndvi_scaled)
# ndvi center = 0.3125089
# ndvi scale = 0.143179

hist(buffalo_CLR_year$ndvi_scaled_raster)
hist(buffalo_CLR_year$water_dist)
hist(buffalo_CLR_year$water_dist_log)
hist(buffalo_CLR_year$herby_scaled)
hist(buffalo_CLR_year$canopy_scaled)
hist(buffalo_CLR_year$DEM_H_end, breaks = 100)
hist(buffalo_CLR_year$elev_scaled, breaks = 100)
hist(buffalo_CLR_year$elev_log, breaks = 100)
# hist(buffalo_CLR_year$elev_log_scaled, breaks = 100)
hist(buffalo_CLR_year$elev_delta, breaks = 100)
hist(buffalo_CLR_year$elev_delta_scaled, breaks = 100)

```



```{r}

ggplot() +
  geom_line(data = buffalo_CLR_year %>% filter(id == 2005), aes(x = month, y = month_s1), size = 0.1) +
  geom_line(data = buffalo_CLR_year %>% filter(id == 2005), aes(x = month, y = month_s2), size = 0.1) +
  geom_line(data = buffalo_CLR_year %>% filter(id == 2005), aes(x = month, y = month_s3), size = 0.1) +
  geom_line(data = buffalo_CLR_year %>% filter(id == 2005), aes(x = month, y = month_s4), size = 0.1) +
  geom_line(data = buffalo_CLR_year %>% filter(id == 2005), aes(x = month, y = month_c1), size = 0.1) +
  geom_line(data = buffalo_CLR_year %>% filter(id == 2005), aes(x = month, y = month_c2), size = 0.1) +
  geom_line(data = buffalo_CLR_year %>% filter(id == 2005), aes(x = month, y = month_c3), size = 0.1) +
  geom_line(data = buffalo_CLR_year %>% filter(id == 2005), aes(x = month, y = month_c4), size = 0.1) +
  theme_classic()

ggplot() +
  geom_line(data = buffalo_CLR_year %>% filter(id == 2005), aes(x = yday, y = yday_s1), size = 0.1) +
  geom_line(data = buffalo_CLR_year %>% filter(id == 2005), aes(x = yday, y = yday_s2), size = 0.1) +
  geom_line(data = buffalo_CLR_year %>% filter(id == 2005), aes(x = yday, y = yday_s3), size = 0.1) +
  geom_line(data = buffalo_CLR_year %>% filter(id == 2005), aes(x = yday, y = yday_s4), size = 0.1) +
  geom_line(data = buffalo_CLR_year %>% filter(id == 2005), aes(x = yday, y = yday_c1), size = 0.1) +
  geom_line(data = buffalo_CLR_year %>% filter(id == 2005), aes(x = yday, y = yday_c2), size = 0.1) +
  geom_line(data = buffalo_CLR_year %>% filter(id == 2005), aes(x = yday, y = yday_c3), size = 0.1) +
  geom_line(data = buffalo_CLR_year %>% filter(id == 2005), aes(x = yday, y = yday_c4), size = 0.1) +
  theme_classic()

```



```{r}

# buffalo_subset <- buffalo_all_covs %>% 
#   filter(year == 2018 & (month == 11 | month == 12) & (id == 2005 | id == 2018)) %>% 
#   drop_na(ndvi_temporal, ndwi_temporal) %>% 
#   mutate(id_num = as.numeric(factor(id)), step_id = step_id_, log_sl = log_sl_, cos_ta = cos_ta_) %>% 
#   dplyr::select(id, id_num, ndvi_temporal, ndwi_temporal, y, step_id)

buffalo_subset <- buffalo_CLR_year %>%
  # filter(year == 2019) %>% # & (id == 2005 | id == 2018) & (month == 11)
  mutate(id_num = as.numeric(factor(id))) %>% 
  dplyr::select(id, id_num, ndvi_scaled, herby_scaled, canopy_scaled, y, step_id, sl, log_sl, cos_ta) %>% 
  drop_na(cos_ta)

sum(is.na(buffalo_subset$cos_ta))

ggplot() +
  geom_point(data = buffalo_subset, aes(x = step_id, y = id_num))

```



```{r}

model <- "data {
  
  int<lower=1> N; // no data points
  int<lower=1> I; // no steps (over all individuals)
  int<lower=1> J; // no individuals
  
  int<lower=0> y[N]; // response
  real ndvi[N]; // covariate
  real herby[N]; // covariate
  real canopy[N]; // covariate
  real sl[N]; // movement covariate
  real log_sl[N]; // movement covariate
  real cos_ta[N]; // movement covariate
  int<lower=1, upper=I> stepid[N]; // step id
  int<lower=1, upper=J> indid[N]; // individual id
  
}

parameters {
  vector[6] beta; // fixed effects
  vector[I] a_re; // RE for steps
  vector[J] i_re_ndvi; // RE effects for each individual - NDVI
  vector[J] i_re_herby; // RE effects for each individual - Herbaceous vegetation
  vector[J] i_re_canopy; // RE effects for each individual - Canopy cover
  vector[J] i_re_sl; // RE effects for each individual - Step length
  vector[J] i_re_log_sl; // RE effects for each individual - Log of step length
  vector[J] i_re_cos_ta; // RE effects for each individual - Cos of turning angle
  
  real<lower = 0.0> sigmaind;
}


model {

  real mu;
  
  // priors
  // maybe add a prior for sd here
  //sigmaind ~ inv_gamma(0.01, 0.01);  
  // unpopular - half-normal / T instead (lower = 0) - try tight parameters

  sigmaind ~ normal(0.0, 5.0); 
  beta ~ normal(0.0, 1.0);
  a_re ~ normal(0.0, 1000000.0);
  i_re_ndvi ~ normal(0.0, sigmaind);
  i_re_herby ~ normal(0.0, sigmaind);
  i_re_canopy ~ normal(0.0, sigmaind);
  i_re_sl ~ normal(0.0, sigmaind);
  i_re_log_sl ~ normal(0.0, sigmaind);
  i_re_cos_ta ~ normal(0.0, sigmaind);
  

  //likelihood


  for (i in 1:N) {

    mu =  a_re[stepid[i]] + 
    (beta[1] + i_re_ndvi[indid[i]]) * ndvi[i] + 
    (beta[2] + i_re_herby[indid[i]]) * herby[i] +
    (beta[3] + i_re_canopy[indid[i]]) * canopy[i] +
    (beta[4] + i_re_sl[indid[i]]) * sl[i] +
    (beta[5] + i_re_log_sl[indid[i]]) * log_sl[i] +
    (beta[6] + i_re_cos_ta[indid[i]]) * cos_ta[i];

    y[i] ~ poisson_log(mu);

  }

}
"

```



```{r}

prior_pred <- "data {

  int<lower = 0> N;
  vector[N] x;
  
  int<lower=1> N; // no data points
  int<lower=1> I; // no steps (over all individuals)
  int<lower=1> J; // no individuals
  
  int<lower=0> y[N]; // response
  real ndvi[N]; // covariate
  real herby[N]; // covariate
  real canopy[N]; // covariate
  real sl[N]; // movement covariate
  real log_sl[N]; // movement covariate
  real cos_ta[N]; // movement covariate
  int<lower=1, upper=I> stepid[N]; // step id
  int<lower=1, upper=J> indid[N]; // individual id
  
}

generated quantities {

  real alpha = normal_rng(0, 1);
  real beta = normal_rng(0, 1);
  real y_sim[N] = poisson_log_rng(alpha + beta * x);
  
  
  
}
"

```




```{r}

# compile the model
tic()
stan_mod <- stan_model(model_code = model)
toc()

# stancode <- 'data {real y_mean;} parameters {real y;} model {y ~ normal(y_mean,1);}'
# mod <- stan_model(model_code = stancode, verbose = TRUE)

beep(sound = 2)

```


```{r}

stan_dat <- list(N = nrow(buffalo_subset), 
                 I = length(unique(buffalo_subset$step_id)), 
                 J = length(unique(buffalo_subset$id_num)), 
                 y = buffalo_subset$y, 
                 ndvi = buffalo_subset$ndvi_scaled[,1], 
                 herby = buffalo_subset$herby_scaled[,1],
                 canopy = buffalo_subset$canopy_scaled[,1],
                 sl = buffalo_subset$sl,
                 log_sl = buffalo_subset$log_sl,
                 cos_ta = buffalo_subset$cos_ta,
                 stepid = as.numeric(factor(buffalo_subset$step_id)), 
                 indid = buffalo_subset$id_num)

```



```{r}

tic()
res_stan_mvmt <- sampling(stan_mod, stan_dat, cores = 4, chains = 2, iter = 100)
toc()

# system("killall R")
# interrupt(res_stan_mvmt)

beep(sound = 2)

```



```{r}

summary(res_stan)$summary[1:10, ]
tail(summary(res_stan)$summary)
traceplot(res_stan,pars=c("beta[1]", "beta[2]", "beta[3]", "a_re[1]", "a_re[2]"))

# print(res_stan)
plot(res_stan, pars = "beta")
plot(res_stan, pars = "beta", plotfun = "stan_hist")
extract(res_stan, pars = "beta")

```




```{r}

clogit_model <- buffalo_subset %>% 
  fit_clogit(case_ ~ 
               ndvi_temporal +
               # ndwi_temporal +
               # #veg_woody +
               # veg_herby +
               # canopy_cover +
               # DEM_H_end +
               # slope_end +
               #WOFS25_dist +
               #WOFS50_dist +
               #WOFS80_dist +
               log_sl_ +
               cos_ta_ +
               # ndvi_temporal:cos_ta_ + 
               # ndvi_temporal:log_sl_ +
               strata(step_id_))


clogit_model
summary(clogit_model)
AIC(clogit_model)

```



### brms

```{r}

tic()

brms_mod <- brm(formula = y ~ -1 +
                  ndvi_temporal +
                  # ndwi_temporal +
                  # veg_herby +
                  # canopy_cover +
                  log_sl +
                  cos_ta +
                  (0 + ndvi_temporal | id),
                  # (0 + ndwi_temporal | id) +
                  # (0 + veg_herby | id) +
                  # (0 + canopy_cover | id), 
                data = buffalo_subset,
                family = poisson(link = log),
                prior = set_prior("normal(0,10", class = "b"),
                warmup = 1000,
                iter = 5000,
                chains = 4)

toc()

summary(brms_mod, waic = TRUE)
plot(brms_mod)
post_pred_subset <- posterior_predict(brms_mod, 
                                      resp = "ndvi_temporal",
                                      ndraws = 100)

```


```{r}

formula_final <- case_ ~

               ndvi_temporal +
               month_s1:ndvi_temporal +
               month_s2:ndvi_temporal +
               month_c1:ndvi_temporal +
               month_c2:ndvi_temporal +

               WOFS05_dist_scaled +
               month_s1:WOFS05_dist_scaled +
               month_s2:WOFS05_dist_scaled +
               month_c1:WOFS05_dist_scaled +
               month_c2:WOFS05_dist_scaled +

               I(WOFS05_dist_scaled^2) +
               month_s1:I(WOFS05_dist_scaled^2) +
               month_s2:I(WOFS05_dist_scaled^2) +
               month_c1:I(WOFS05_dist_scaled^2) +
               month_c2:I(WOFS05_dist_scaled^2) +

               # elev_scaled +
               # month_s1:elev_scaled +
               # month_s2:elev_scaled +
               # month_c1:elev_scaled +
               # month_c2:elev_scaled +
               # 
               # I(elev_scaled^2) +
               # month_s1:I(elev_scaled^2) +
               # month_s2:I(elev_scaled^2) +
               # month_c1:I(elev_scaled^2) +
               # month_c2:I(elev_scaled^2) +

               slope_scaled +
               month_s1:slope_scaled +
               month_s2:slope_scaled +
               month_c1:slope_scaled +
               month_c2:slope_scaled +

               veg_herby +
                month_s1:veg_herby +
               month_s2:veg_herby +
               month_c1:veg_herby +
               month_c2:veg_herby +

               canopy_01 +
               month_s1:canopy_01 +
               month_s2:canopy_01 +
               month_c1:canopy_01 +
               month_c2:canopy_01 +

               log_sl_ +
               month_s1:log_sl_ +
               month_s2:log_sl_ +
               month_c1:log_sl_ +
               month_c2:log_sl_ +

               cos_ta_ +
               month_s1:cos_ta_ +
               month_s2:cos_ta_ +
               month_c1:cos_ta_ +
               month_c2:cos_ta_ +

               strata(step_id_)

```

