---
title: "SSF CLR fitting and prediction"
author: "Scott Forrest"
date: "`r Sys.Date()`"
output: html_document
editor_options: 
  chunk_output_type: inline
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Import packages

```{r message = FALSE}

options(scipen=999)

# install.packages("forecast")
# install.packages("TwoStepCLogit")

library(tidyverse)

packages <- c("amt", "lubridate", "mgcv", "survival", "terra", "raster", "tictoc", 
              "RColorBrewer", "patchwork", "ecospat", "ggmap", "basemaps", "mapedit", 
              "sf", "ggpubr", "circular", "forecast", "TwoStepCLogit")

walk(packages, require, character.only = T)

```

With 2 pairs of harmonics and quadratics

```{r two harmonics}

# auto.arima()

formula_twostep <- y ~ 
  
  ndvi_scaled +
  hour_s1:ndvi_scaled +
  hour_s2:ndvi_scaled +
  # hour_s3:ndvi_scaled +
  hour_c1:ndvi_scaled +
  hour_c2:ndvi_scaled +
  # hour_c3:ndvi_scaled +
  
  ndvi_2 +
  hour_s1:ndvi_2 +
  hour_s2:ndvi_2 +
  # hour_s3:ndvi_2 +
  hour_c1:ndvi_2 +
  hour_c2:ndvi_2 +
  # hour_c3:ndvi_2 +

  canopy_scaled +
  hour_s1:canopy_scaled +
  hour_s2:canopy_scaled +
  # hour_s3:canopy_scaled +
  hour_c1:canopy_scaled +
  hour_c2:canopy_scaled +
  # hour_c3:canopy_scaled +
  
  canopy_2 +
  hour_s1:canopy_2 +
  hour_s2:canopy_2 +
  # hour_s3:canopy_2 +
  hour_c1:canopy_2 +
  hour_c2:canopy_2 +
  # hour_c3:canopy_2 +
  
  sl +
  hour_s1:sl +
  hour_s2:sl +
  # hour_s3:sl +
  hour_c1:sl +
  hour_c2:sl +
  # hour_c3:sl +

  log_sl +
  hour_s1:log_sl +
  hour_s2:log_sl +
  # hour_s3:log_sl +
  hour_c1:log_sl +
  hour_c2:log_sl +
  # hour_c3:log_sl +
  
  cos_ta +
  hour_s1:cos_ta +
  hour_s2:cos_ta +
  # hour_s3:cos_ta +
  hour_c1:cos_ta +
  hour_c2:cos_ta +
  # hour_c3:cos_ta +
  
  strata(step_id) +
  cluster(id)

```


With 3 pairs of harmonics 

```{r three harmonics}

# auto.arima()

formula_twostep <- y ~ 
  
  ndvi_scaled +
  hour_s1:ndvi_scaled +
  hour_s2:ndvi_scaled +
  hour_s3:ndvi_scaled +
  # hour_s4:ndvi_scaled +
  # hour_s5:ndvi_scaled +
  # hour_s6:ndvi_scaled +
  
  hour_c1:ndvi_scaled +
  hour_c2:ndvi_scaled +
  hour_c3:ndvi_scaled +
  # hour_c4:ndvi_scaled +
  # hour_c5:ndvi_scaled +
  # hour_c6:ndvi_scaled +
  
  ndvi_2 +
  hour_s1:ndvi_2 +
  hour_s2:ndvi_2 +
  hour_s3:ndvi_2 +
  # hour_s4:ndvi_2 +
  # hour_s5:ndvi_2 +
  # hour_s6:ndvi_2 +
  
  hour_c1:ndvi_2 +
  hour_c2:ndvi_2 +
  hour_c3:ndvi_2 +
  # hour_c4:ndvi_2 +
  # hour_c5:ndvi_2 +
  # hour_c6:ndvi_2 +

  canopy_scaled +
  hour_s1:canopy_scaled +
  hour_s2:canopy_scaled +
  hour_s3:canopy_scaled +
  # hour_s4:canopy_scaled +
  # hour_s5:canopy_scaled +
  # hour_s6:canopy_scaled +
  
  hour_c1:canopy_scaled +
  hour_c2:canopy_scaled +
  hour_c3:canopy_scaled +
  # hour_c4:canopy_scaled +
  # hour_c5:canopy_scaled +
  # hour_c6:canopy_scaled +
  
  canopy_2 +
  hour_s1:canopy_2 +
  hour_s2:canopy_2 +
  hour_s3:canopy_2 +
  # hour_s4:canopy_2 +
  # hour_s5:canopy_2 +
  # hour_s6:canopy_2 +
  
  hour_c1:canopy_2 +
  hour_c2:canopy_2 +
  hour_c3:canopy_2 +
  # hour_c4:canopy_2 +
  # hour_c5:canopy_2 +
  # hour_c6:canopy_2 +
  
  sl +
  hour_s1:sl +
  hour_s2:sl +
  hour_s3:sl +
  # hour_s4:sl +
  # hour_s5:sl +
  # hour_s6:sl +
  
  hour_c1:sl +
  hour_c2:sl +
  hour_c3:sl +
  # hour_c4:sl +
  # hour_c5:sl +
  # hour_c6:sl +
  
  log_sl +
  hour_s1:log_sl +
  hour_s2:log_sl +
  hour_s3:log_sl +
  # hour_s4:log_sl +
  # hour_s5:log_sl +
  # hour_s6:log_sl +
  
  hour_c1:log_sl +
  hour_c2:log_sl +
  hour_c3:log_sl +
  # hour_c4:log_sl +
  # hour_c5:log_sl +
  # hour_c6:log_sl +
  
  cos_ta +
  hour_s1:cos_ta +
  hour_s2:cos_ta +
  hour_s3:cos_ta +
  # hour_s4:cos_ta +
  # hour_s5:cos_ta +
  # hour_s6:cos_ta +
  
  hour_c1:cos_ta +
  hour_c2:cos_ta +
  hour_c3:cos_ta +
  # hour_c4:cos_ta +
  # hour_c5:cos_ta +
  # hour_c6:cos_ta +
  
  strata(step_id) +
  cluster(id)

```

Fitting the model

```{r twostep model fit}

month_no <- 3
buffalo_model_data <- buffalo_CLR_year_harmonics %>% dplyr::filter(month == month_no)

tic()
model_twostep <- Ts.estim(formula = formula_twostep,
         data = buffalo_model_data,
         # random = , # default = all covariates
         all.m.1 = TRUE,
         D = "UN(1)",
         itermax = 10000) # default = 2000
toc()

# model_twostep_2harms <- model_twostep
# model_twostep_2harms_quads <- model_twostep
# model_twostep_3harms <- model_twostep
# model_twostep <- model_twostep_3harms

```

Summary of model fit

```{r two step summary}

model_twostep
# summary(model_twostep)
# print(model_twostep)

```

Reconstructing coefficients with two harmonics with quadratics

```{r}

hour <- seq(0,24,0.1)
# hour <- seq(1,24,1)

hour_harmonics_df <- data.frame("hour_s1" = sin(2*pi*hour/24),
                                "hour_s2" = sin(4*pi*hour/24),
                                # "hour_s3" = sin(6*pi*hour/24),
                                # "hour_s4" = sin(8*pi*hour/24),
                                "hour_c1" = cos(2*pi*hour/24),
                                "hour_c2" = cos(4*pi*hour/24))
                                # "hour_c3" = cos(6*pi*hour/24),
                                # "hour_c4" = cos(8*pi*hour/24))

# plot(x = hour, y = hour_harmonics_df$hour_s1, type = "l")

coef_names <- names(model_twostep$beta)[1:7] # only get linear terms
harmonic_coefs_list <- vector(mode = "list", length = length(coef_names))

for(i in 1:length(coef_names)) {
harmonic_coefs_list[[i]] <- c(model_twostep$beta[which(names(model_twostep$beta) == paste0(coef_names[i]))],
                              model_twostep$beta[which(names(model_twostep$beta) == paste0(coef_names[i], ":hour_s1"))],
                               model_twostep$beta[which(names(model_twostep$beta) == paste0(coef_names[i], ":hour_s2"))],
                               model_twostep$beta[which(names(model_twostep$beta) == paste0(coef_names[i], ":hour_s3"))],
                               model_twostep$beta[which(names(model_twostep$beta) == paste0(coef_names[i], ":hour_c1"))],
                               model_twostep$beta[which(names(model_twostep$beta) == paste0(coef_names[i], ":hour_c2"))],
                               model_twostep$beta[which(names(model_twostep$beta) == paste0(coef_names[i], ":hour_c3"))])
}


for(i in 1:length(coef_names)) {
plot(x = hour, 
     y = (harmonic_coefs_list[[i]][1] + 
            as.matrix(hour_harmonics_df) %*% 
            harmonic_coefs_list[[i]][2:5]),  
     main = paste0(coef_names[i]),
     ylab = "Temporally varying coefficient",
     type = "l")
}


hourly_coefs_2harms_quads <- data.frame("hour" = hour,
                                  "ndvi" = harmonic_coefs_list[[1]][1] + as.matrix(hour_harmonics_df) %*% harmonic_coefs_list[[1]][2:5],
                                  "ndvi_quad" = harmonic_coefs_list[[2]][1] + as.matrix(hour_harmonics_df) %*% harmonic_coefs_list[[2]][2:5],
                                  "canopy" = harmonic_coefs_list[[3]][1] + as.matrix(hour_harmonics_df) %*% harmonic_coefs_list[[3]][2:5],
                                  "canopy_quad" = harmonic_coefs_list[[4]][1] + as.matrix(hour_harmonics_df) %*% harmonic_coefs_list[[4]][2:5],
                                  "sl" = harmonic_coefs_list[[5]][1] + as.matrix(hour_harmonics_df) %*% harmonic_coefs_list[[5]][2:5],
                                  "log_sl" = harmonic_coefs_list[[6]][1] + as.matrix(hour_harmonics_df) %*% harmonic_coefs_list[[6]][2:5],
                                  "cos_ta" = harmonic_coefs_list[[7]][1] + as.matrix(hour_harmonics_df) %*% harmonic_coefs_list[[7]][2:5])

```

Reconstructing the Gamma and von Mises distributions from the tentative distributions (from Fieberg et al 2021: Appendix C)

```{r}

# for individuals
# movement_parameters <- read_csv("outputs/buffalo_parametric_indv_movement_params_20230208.csv")
# movement_parameters_year <- movement_parameters %>% filter(id %in% buffalo_year_ids)

# for the population
# gamma$params$shape # 0.438167
# gamma$params$scale # 534.3507
# vonmises$params$kappa # 0.1848126

tentative_shape <- 0.438167
tentative_scale <- 534.3507
tentative_kappa <- 0.1848126

hourly_coefs_2harms_quads <- hourly_coefs_2harms_quads %>% mutate(shape = tentative_shape + log_sl,
                             scale = 1/((1/tentative_scale) - sl),
                             kappa = tentative_kappa + cos_ta)

# write_csv(harmonic_coefs_df, "outputs/harmonic_coefs_df_with_movement_params_ndvi_canopy_quads_20230519.csv")

# turning into a long data frame
hourly_coefs_2harms_quads_long <- pivot_longer(hourly_coefs_2harms_quads, cols = !1, names_to = "coef")
head(hourly_coefs_2harms_quads_long)

# write_csv(harmonic_coefs, "outputs/harmonic_coefs_df_long_with_movement_params_ndvi_canopy_quads_20230519.csv")

```



```{r}

coefs <- unique(hourly_coefs_2harms_quads_long$coef)
# coef_titles <- c("NDVI", "Slope", "Herbaceous vegetation", "Canopy cover", "Step length", "log(Step length)", "cos(Turning angle)")

ggplot() +
    geom_path(data = hourly_coefs_2harms_quads_long %>%
                filter(coef %in% unique(hourly_coefs_2harms_quads_long$coef)[1:4]),
              aes(x = hour, y = value, colour = coef)) +
    geom_hline(yintercept = 0, linetype = "dashed") +
    scale_y_continuous(expression(Time-varying~parameter~values~beta)) +
    scale_x_continuous("Hour of the day") +
    scale_color_discrete("Estimate") +
    # ggtitle(coef_titles[i]) +
    theme_classic() +
    theme(legend.position = "bottom")

# ggsave(paste("outputs/plots/clr_fitting/clr_3harmonics_all_quads_20230519.png", sep = ""),
#   width=150, height=90, units="mm", dpi = 300)
# ggsave(paste("outputs/plots/clr_fitting/clr_harmonic_all_pres_20230208.png", sep = ""),
#   width=300, height=180, units="mm", dpi = 300)

ggplot() +
    geom_path(data = hourly_coefs_2harms_quads_long %>% 
                filter(coef %in% unique(hourly_coefs_2harms_quads_long$coef)[c(8,10)]), 
              aes(x = hour, y = value, colour = coef)) +
    geom_hline(yintercept = 0, linetype = "dashed") +
    scale_y_continuous(expression(beta)) +
    # scale_x_continuous(breaks = 0:24) +
    scale_color_discrete("Estimate") +
    # ggtitle(coef_titles[i]) +
    theme_classic() +
    theme(legend.position = "bottom")

ggplot() +
    geom_path(data = hourly_coefs_2harms_quads_long %>% 
                filter(coef %in% unique(hourly_coefs_2harms_quads_long$coef)[9]), 
              aes(x = hour, y = value, colour = coef)) +
    geom_hline(yintercept = 0, linetype = "dashed") +
    scale_y_continuous(expression(beta)) +
    # scale_x_continuous(breaks = 0:24) +
    scale_color_discrete("Estimate") +
    # ggtitle(coef_titles[i]) +
    theme_classic() +
    theme(legend.position = "bottom")

```




```{r}

x <- seq(0, 1000, length = 500)

# with tentative parameters
plot(x, dgamma(x, shape = tentative_shape, scale = tentative_scale), type = "l")

temporal_movement_params <- hourly_coefs_2harms_quads %>% dplyr::select(c("hour", "shape", "scale", "kappa"))
# write_csv(temporal_movement_params, "outputs/temporal_movement_params_CLR_20230210.csv")

ggplot() +
  stat_function(fun = dgamma, args = list(shape = tentative_shape, scale = tentative_scale)) +
  scale_x_continuous(limits = c(0,1000), breaks = seq(0,1000,100)) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  theme_classic()

# subset <- temporal_movement_params %>% filter(month < 1)

# ggplot(subset) +
#   stat_function(fun = dgamma, args = list(shape = shape, scale = scale)) +
#   scale_x_continuous(limits = c(0,1000), breaks = seq(0,1000,100)) +
#   geom_hline(yintercept = 0, linetype = "dashed") +
#   theme_classic()

```


# Generating predictions

Use the habitat layer script to import habitat layers

Checking distributions of covariates vs used and random locations

```{r}

# ndvi_values_month1 <- values(ndvi_above0_stack_scaled[[13]])
# canopy_values <- values(canopy_cover)
# # slope_values <- values(slope_scaled)
# # herby_values <- values(veg_herby)
# 
# enviro_values <- data.frame("Data" = rep("Environmental", length(values(canopy_cover))), "pres" = rep(1, length(values(canopy_cover))),  "ndvi" = ndvi_values_month1, "canopy" = canopy_values, "slope" = slope_values, "herby" = herby_values)
# names(enviro_values) <- c("Data", "pres", "ndvi", "canopy", "slope", "herby")
# 
# buffalo_pres_values <- buffalo_CLR_year %>% filter(y == 1 & year == 2019 & month == 3) %>%  transmute(Data = "Presence", pres = y, ndvi = ndvi_temporal, canopy = canopy_cover, slope = slope_end, herby = veg_herby)
# 
# buffalo_background_values <- buffalo_CLR_year %>% filter(y == 0 & year == 2019 & month == 3) %>%  transmute(Data = "Random steps", pres = y, ndvi = ndvi_temporal, canopy = canopy_cover, slope = slope_end, herby = veg_herby)
# 
# enviro_buffalo_values <- rbind(enviro_values, buffalo_pres_values, buffalo_background_values)
# 
# # ggplot(enviro_buffalo_values) +
# #   geom_density(aes(x = ndvi, fill = method), alpha = 0.5) +
# #   geom_density(data = buffalo_CLR_year %>% filter(y == 1, year == 2019 & month == 1), 
# #                aes(x = ndvi_temporal), fill = "orange", alpha = 0.5) +
# #   geom_density(data = buffalo_CLR_year %>% filter(y == 0, year == 2019 & month == 1), 
# #                aes(x = ndvi_temporal), linetype = "dashed", colour = "red", alpha = 0.5) +
# #   theme_classic()
# 
# ggplot() +
#   geom_density(data = enviro_buffalo_values, aes(x = ndvi, fill = Data), alpha = 0.25) +
#   theme_classic()
# 
# ggplot() +
#   geom_density(data = enviro_buffalo_values, aes(x = slope, fill = Data), alpha = 0.25) +
#   theme_classic()
# 
# 
# tab <- as.data.frame(prop.table(table(enviro_buffalo_values$canopy, enviro_buffalo_values$Data), 2))
# names(tab) <- c("Canopy_cover", "Data", "Freq")
# 
# ggplot(data = tab, aes(x = Canopy_cover, y = Freq, fill = Data)) +
#   geom_bar(stat = "identity", position = position_dodge(), alpha = 0.75) +
#   theme_classic()

```


# Predictions and cross-validation

Boyce index function

```{r}

ecospat.boyce2 <- function (fit, obs, nclass = 0, window.w = "default", res = 100, 
  PEplot = TRUE, rm.duplicate = TRUE, method = "spearman") 
{
  boycei <- function(interval, obs, fit) {
    pi <- sum(as.numeric(obs >= interval[1] & obs <= interval[2]))/length(obs)
    ei <- sum(as.numeric(fit >= interval[1] & fit <= interval[2]))/length(fit)
    return(round(pi/ei, 10))
  }
  if (inherits(fit, "RasterLayer")) {
    if (is.data.frame(obs) || is.matrix(obs)) {
      obs <- raster::extract(fit, obs)
    }
    fit <- getValues(fit)
    fit <- fit[!is.na(fit)]
    obs <- obs[!is.na(obs)]
  }
  mini <- min(fit, obs)
  maxi <- max(fit, obs)
  if (length(nclass) == 1) {
    if (nclass == 0) {
      if (window.w == "default") {
        window.w <- (max(fit) - min(fit))/10
      }
      vec.mov <- seq(from = mini, to = maxi - window.w, 
        by = (maxi - mini - window.w)/res)
      vec.mov[res + 1] <- vec.mov[res + 1] + 1
      interval <- cbind(vec.mov, vec.mov + window.w)
    }
    else {
      vec.mov <- seq(from = mini, to = maxi, by = (maxi - 
        mini)/nclass)
      interval <- cbind(vec.mov, c(vec.mov[-1], maxi))
    }
  }
  else {
    vec.mov <- c(mini, sort(nclass[!nclass > maxi | nclass < 
      mini]))
    interval <- cbind(vec.mov, c(vec.mov[-1], maxi))
  }
  f <- apply(interval, 1, boycei, obs, fit)
  to.keep <- which(f != "NaN")
  f <- f[to.keep]
  if (length(f) < 2) {
    b <- NA
  }
  else {
    r <- 1:length(f)
    if (rm.duplicate == TRUE) {
      r <- c(1:length(f))[f != c(f[-1], TRUE)]
    }
    b <- cor(f[r], vec.mov[to.keep][r], method = method)
  }
  HS <- apply(interval, 1, sum)/2
  if (length(nclass) == 1 & nclass == 0) {
    HS[length(HS)] <- HS[length(HS)] - 1
  }
  HS <- HS[to.keep]
  if (PEplot == TRUE) {
    plot(HS, f, xlab = "Habitat suitability", ylab = "Predicted/Expected ratio", 
      col = "grey", cex = 0.75)
    points(HS[r], f[r], pch = 19, cex = 0.75)
  }
  return(list(F.ratio = f, cor = round(b, 3), HS = HS))
}

```

Naive approach

```{r}

naive_pred_stack <- c()
boyce_naive_list <- vector(mode = "list", length = 24)

for(i in 1:24) {
  
  # i = 24

resources <- c(ndvi_stack_scaled[[12 + month_no]], 
               # slope_scaled,
               # veg_herby, 
               canopy_scaled)

# ndvi
ndvi_lin <- resources[[1]]
ndvi_lin <- ndvi_lin * hourly_coefs_2harms_quads$ndvi[[which(hourly_coefs_2harms_quads$hour == i)]]
# plot(ndvi_lin)

ndvi_quad <- resources[[1]]
ndvi_quad <- (ndvi_quad ^ 2) * hourly_coefs_2harms_quads$ndvi_quad[[which(hourly_coefs_2harms_quads$hour == i)]]
# plot(ndvi_quad)

ndvi_pred <- ndvi_lin  + ndvi_quad
plot(ndvi_pred)

# canopy cover 
canopy_lin <- resources[[2]]
canopy_lin <- canopy_lin * hourly_coefs_2harms_quads$canopy[[which(hourly_coefs_2harms_quads$hour == i)]]
# plot(canopy_lin)

canopy_quad <- resources[[2]]
canopy_quad <- (canopy_quad ^ 2) * hourly_coefs_2harms_quads$canopy_quad[[which(hourly_coefs_2harms_quads$hour == i)]]
# plot(canopy_quad)

canopy_pred <- canopy_lin + canopy_quad
plot(canopy_pred)

# combining
naive_pred <- exp(ndvi_pred + canopy_pred) / global(exp(ndvi_pred + canopy_pred), fun = "sum", na.rm = TRUE)[[1]]
plot(naive_pred)
plot(naive_pred)
points(as.numeric(buffalo_CLR_year %>% 
                    filter(y == 1 & month == month_no & hour == ifelse(i == 24, 0, i)) %>% 
                    dplyr::select(x1) %>% unlist()), 
       as.numeric(buffalo_CLR_year %>% 
                    filter(y == 1 & month == month_no & hour == ifelse(i == 24, 0, i)) %>% 
                    dplyr::select(y1) %>% unlist()))

naive_pred_stack <- c(naive_pred_stack, naive_pred)

# setting up the buffalo observation data for the relevant month

# buffalo_obs <- buffalo_CLR_year %>% 
#   filter(y == 1 & month == 1 & x1 > xmin & x1 < xmax & y1 > ymin & y1 < ymax) %>% 
#   transmute(x = x1 - xmin, y = y1 - ymin)

buffalo_obs <- buffalo_CLR_year %>% 
  filter(y == 1 & month == month_no & hour == ifelse(i == 24, 0, i)) %>% 
  transmute(x = x1, y = y1)

naive_raster <- raster(naive_pred)
# naive_raster <- raster(naive_pred_cropped)

# plot(naive_pred)
# plot(naive_raster)

# plot(naive_cropped_raster[[1]])

# boyce_naive <- ecospat.boyce2(naive_cropped_raster[[1]], buffalo_obs,
#                               # method = "spearman"
#                               method = "pearson",
#                               # method = "kendall"
#                               )

boyce_naive_list[[i]] <- ecospat.boyce2(naive_raster, buffalo_obs,
                              method = "spearman"
                              # method = "pearson",
                              # method = "kendall"
                              )

boyce_naive_list[[i]]

}

# naive_raster_2harms <- naive_raster
# boyce_naive_list_2harms <- boyce_naive_list

naive_raster_daily_2harms_quads <- naive_raster
boyce_naive_raster_daily_2harms_quads <- boyce_naive_list

```


```{r}

for(i in 1:24) {
  plot(naive_pred_stack[[i]])
}

for(i in 1:24) {
  # plot(naive_pred_stack[[i]])
  plot(naive_pred_stack[[i]])
  points(as.numeric(buffalo_CLR_year %>% filter(y == 1 & month == month_no & hour == ifelse(i == 24, 0, i)) %>% dplyr::select(x1) %>% unlist()), 
       as.numeric(buffalo_CLR_year %>% filter(y == 1 & month == month_no & hour == ifelse(i == 24, 0, i)) %>% dplyr::select(y1) %>% unlist()))
}

```


```{r}

spearman_cor <- c()

for(i in 1:24) {
  print(boyce_naive_list[[i]]$cor)
  spearman_cor[i] <- boyce_naive_list[[i]]$cor
}

mean(spearman_cor)
sd(spearman_cor)

```


notes:

- for ndvi and canopy with quadratics the predictions are really bad in the night - is this a statistical artifact or do they respond to something at night that we aren't included in the model..?



# NDVI, canopy cover and herbaceous vegetation

With 2 pairs of harmonics and quadratics

```{r two harmonics}

formula_twostep <- y ~ 
  
  ndvi_scaled +
  hour_s1:ndvi_scaled +
  hour_s2:ndvi_scaled +
  # hour_s3:ndvi_scaled +
  hour_c1:ndvi_scaled +
  hour_c2:ndvi_scaled +
  # hour_c3:ndvi_scaled +
  
  ndvi_2 +
  hour_s1:ndvi_2 +
  hour_s2:ndvi_2 +
  # hour_s3:ndvi_2 +
  hour_c1:ndvi_2 +
  hour_c2:ndvi_2 +
  # hour_c3:ndvi_2 +

  canopy_scaled +
  hour_s1:canopy_scaled +
  hour_s2:canopy_scaled +
  # hour_s3:canopy_scaled +
  hour_c1:canopy_scaled +
  hour_c2:canopy_scaled +
  # hour_c3:canopy_scaled +
  
  canopy_2 +
  hour_s1:canopy_2 +
  hour_s2:canopy_2 +
  # hour_s3:canopy_2 +
  hour_c1:canopy_2 +
  hour_c2:canopy_2 +
  # hour_c3:canopy_2 +
  
  herby_scaled +
  hour_s1:herby_scaled +
  hour_s2:herby_scaled +
  # hour_s3:herby_scaled +
  hour_c1:herby_scaled +
  hour_c2:herby_scaled +
  # hour_c3:herby_scaled +
  
  sl +
  hour_s1:sl +
  hour_s2:sl +
  # hour_s3:sl +
  hour_c1:sl +
  hour_c2:sl +
  # hour_c3:sl +

  log_sl +
  hour_s1:log_sl +
  hour_s2:log_sl +
  # hour_s3:log_sl +
  hour_c1:log_sl +
  hour_c2:log_sl +
  # hour_c3:log_sl +
  
  cos_ta +
  hour_s1:cos_ta +
  hour_s2:cos_ta +
  # hour_s3:cos_ta +
  hour_c1:cos_ta +
  hour_c2:cos_ta +
  # hour_c3:cos_ta +
  
  strata(step_id) +
  cluster(id)

```

Subset data to wet/dry season

```{r twostep model fit}

month_no <- 3
buffalo_model_data <- buffalo_CLR_year_harmonics %>% dplyr::filter(month == month_no)

months_wet <- c(1:4, 11, 12)
buffalo_model_data_wet <- buffalo_CLR_year_harmonics %>% dplyr::filter(month %in% months_wet)
buffalo_model_data_dry <- buffalo_CLR_year_harmonics %>% dplyr::filter(!month %in% months_wet)

```

Fit the model

```{r}

tic()
model_twostep <- Ts.estim(formula = formula_twostep,
         data = buffalo_model_data_wet,
         all.m.1 = TRUE,
         D = "UN(1)",
         itermax = 10000) # default = 2000
toc()

# model_twostep_2harms <- model_twostep
# model_twostep_2harms_w_herby_quads_dry <- model_twostep
model_twostep_2harms_w_herby_quads_wet <- model_twostep
# model_twostep_3harms_w_herby_quads_dry <- model_twostep
# model_twostep_3harms <- model_twostep
# model_twostep <- model_twostep_3harms

```

Summary of model fit

```{r two step summary}

model_twostep
# summary(model_twostep)
# print(model_twostep)

```

Reconstructing coefficients with two harmonics with quadratics

```{r}

hour <- seq(0,24,0.1)
# hour <- seq(1,24,1)

hour_harmonics_df <- data.frame("hour_s1" = sin(2*pi*hour/24),
                                "hour_s2" = sin(4*pi*hour/24),
                                # "hour_s3" = sin(6*pi*hour/24),
                                # "hour_s4" = sin(8*pi*hour/24),
                                "hour_c1" = cos(2*pi*hour/24),
                                "hour_c2" = cos(4*pi*hour/24)
                                # "hour_c3" = cos(6*pi*hour/24),
                                # "hour_c4" = cos(8*pi*hour/24)
                                )

# plot(x = hour, y = hour_harmonics_df$hour_s1, type = "l")

coef_names <- names(model_twostep$beta)[1:8] # only get linear terms

harmonic_coefs_list <- vector(mode = "list", length = length(coef_names))

for(i in 1:length(coef_names)) {
harmonic_coefs_list[[i]] <- c(model_twostep$beta[which(names(model_twostep$beta) == paste0(coef_names[i]))],
                              model_twostep$beta[which(names(model_twostep$beta) == paste0(coef_names[i], ":hour_s1"))],
                               model_twostep$beta[which(names(model_twostep$beta) == paste0(coef_names[i], ":hour_s2"))],
                               model_twostep$beta[which(names(model_twostep$beta) == paste0(coef_names[i], ":hour_s3"))],
                               model_twostep$beta[which(names(model_twostep$beta) == paste0(coef_names[i], ":hour_c1"))],
                               model_twostep$beta[which(names(model_twostep$beta) == paste0(coef_names[i], ":hour_c2"))],
                               model_twostep$beta[which(names(model_twostep$beta) == paste0(coef_names[i], ":hour_c3"))])
}


for(i in 1:length(coef_names)) {
plot(x = hour, 
     y = (harmonic_coefs_list[[i]][1] + 
            as.matrix(hour_harmonics_df) %*% 
            harmonic_coefs_list[[i]][2:5]),  
     main = paste0(coef_names[i]),
     ylab = "Temporally varying coefficient",
     type = "l")
}


hourly_coefs_2harms_quads <- data.frame("hour" = hour,
                                  "ndvi" = harmonic_coefs_list[[1]][1] + as.matrix(hour_harmonics_df) %*% harmonic_coefs_list[[1]][2:5],
                                  "ndvi_quad" = harmonic_coefs_list[[2]][1] + as.matrix(hour_harmonics_df) %*% harmonic_coefs_list[[2]][2:5],
                                  "canopy" = harmonic_coefs_list[[3]][1] + as.matrix(hour_harmonics_df) %*% harmonic_coefs_list[[3]][2:5],
                                  "canopy_quad" = harmonic_coefs_list[[4]][1] + as.matrix(hour_harmonics_df) %*% harmonic_coefs_list[[4]][2:5],
                                  "herby" = harmonic_coefs_list[[5]][1] + as.matrix(hour_harmonics_df) %*% harmonic_coefs_list[[5]][2:5],
                                  "sl" = harmonic_coefs_list[[6]][1] + as.matrix(hour_harmonics_df) %*% harmonic_coefs_list[[6]][2:5],
                                  "log_sl" = harmonic_coefs_list[[7]][1] + as.matrix(hour_harmonics_df) %*% harmonic_coefs_list[[7]][2:5],
                                  "cos_ta" = harmonic_coefs_list[[8]][1] + as.matrix(hour_harmonics_df) %*% harmonic_coefs_list[[8]][2:5])


# there's surely a way to loop this

# i = 1
# hourly_coefs_2harms_quads <- data.frame("hour" = hour,
#                                   paste0(coef_names[i]) = harmonic_coefs_list[[i]][1] + 
#                                     as.matrix(hour_harmonics_df) %*% harmonic_coefs_list[[i]][2:5])

```

Reconstructing the Gamma and von Mises distributions from the tentative distributions (from Fieberg et al 2021: Appendix C)

```{r}

# for individuals
# movement_parameters <- read_csv("outputs/buffalo_parametric_indv_movement_params_20230208.csv")
# movement_parameters_year <- movement_parameters %>% filter(id %in% buffalo_year_ids)

# for the population
# gamma$params$shape # 0.438167
# gamma$params$scale # 534.3507
# vonmises$params$kappa # 0.1848126

tentative_shape <- 0.438167
tentative_scale <- 534.3507
tentative_kappa <- 0.1848126

hourly_coefs_2harms_quads <- hourly_coefs_2harms_quads %>% mutate(shape = tentative_shape + log_sl,
                             scale = 1/((1/tentative_scale) - sl),
                             kappa = tentative_kappa + cos_ta)

write_csv(hourly_coefs_2harms_quads, "outputs/daily_2harmonic_coefs_df_ndvi_canopy_herby_quads_wet_20230524.csv")

# turning into a long data frame
hourly_coefs_2harms_quads_long <- pivot_longer(hourly_coefs_2harms_quads, cols = !1, names_to = "coef")
head(hourly_coefs_2harms_quads_long)

# write_csv(harmonic_coefs, "outputs/harmonic_coefs_df_long_with_movement_params_ndvi_canopy_quads_20230519.csv")

```

```{r}

coefs <- unique(hourly_coefs_2harms_quads_long$coef)
# coef_titles <- c("NDVI", "Slope", "Herbaceous vegetation", "Canopy cover", "Step length", "log(Step length)", "cos(Turning angle)")

ggplot() +
    geom_path(data = hourly_coefs_2harms_quads_long %>%
                filter(coef %in% unique(hourly_coefs_2harms_quads_long$coef)[1:5]),
              aes(x = hour, y = value, colour = coef)) +
    geom_hline(yintercept = 0, linetype = "dashed") +
    scale_y_continuous(expression(Time-varying~parameter~values~beta)) +
    scale_x_continuous("Hour of the day") +
    scale_color_discrete("Estimate") +
    # ggtitle(coef_titles[i]) +
    theme_classic() +
    theme(legend.position = "bottom")

# ggsave(paste("outputs/plots/clr_fitting/clr_3harmonics_all_quads_20230519.png", sep = ""),
#   width=150, height=90, units="mm", dpi = 300)
# ggsave(paste("outputs/plots/clr_fitting/clr_harmonic_all_pres_20230208.png", sep = ""),
#   width=300, height=180, units="mm", dpi = 300)

ggplot() +
    geom_path(data = hourly_coefs_2harms_quads_long %>% 
                filter(coef %in% unique(hourly_coefs_2harms_quads_long$coef)[c(9,11)]), 
              aes(x = hour, y = value, colour = coef)) +
    geom_hline(yintercept = 0, linetype = "dashed") +
    scale_y_continuous(expression(beta)) +
    # scale_x_continuous(breaks = 0:24) +
    scale_color_discrete("Estimate") +
    # ggtitle(coef_titles[i]) +
    theme_classic() +
    theme(legend.position = "bottom")

ggplot() +
    geom_path(data = hourly_coefs_2harms_quads_long %>% 
                filter(coef %in% unique(hourly_coefs_2harms_quads_long$coef)[10]), 
              aes(x = hour, y = value, colour = coef)) +
    geom_hline(yintercept = 0, linetype = "dashed") +
    scale_y_continuous(expression(beta)) +
    # scale_x_continuous(breaks = 0:24) +
    scale_color_discrete("Estimate") +
    # ggtitle(coef_titles[i]) +
    theme_classic() +
    theme(legend.position = "bottom")

```

```{r}

x <- seq(-5,5,0.1)
y <- (-0.25 * x) + (-.15 * x^2)

plot(x, y, xlim = c(-5,5), ylim = c(-5, 5))

```



```{r}

x <- seq(0, 1000, length = 500)

# with tentative parameters
plot(x, dgamma(x, shape = tentative_shape, scale = tentative_scale), type = "l")

temporal_movement_params <- hourly_coefs_2harms_quads %>% dplyr::select(c("hour", "shape", "scale", "kappa"))
# write_csv(temporal_movement_params, "outputs/temporal_movement_params_CLR_20230210.csv")

ggplot() +
  stat_function(fun = dgamma, args = list(shape = tentative_shape, scale = tentative_scale)) +
  scale_x_continuous(limits = c(0,1000), breaks = seq(0,1000,100)) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  theme_classic()

# subset <- temporal_movement_params %>% filter(month < 1)

# ggplot(subset) +
#   stat_function(fun = dgamma, args = list(shape = shape, scale = scale)) +
#   scale_x_continuous(limits = c(0,1000), breaks = seq(0,1000,100)) +
#   geom_hline(yintercept = 0, linetype = "dashed") +
#   theme_classic()

```


# Generating predictions

Use the habitat layer script to import habitat layers

Checking distributions of covariates vs used and random locations

```{r}

ndvi_values_month <- values(ndvi_stack_scaled[[12 + month_no]])
canopy_values <- values(canopy_scaled)
# slope_values <- values(slope_scaled)
herby_values <- values(herby_scaled)

enviro_values <- data.frame("Data" = "Environmental", 
                            "pres" = 1,
                            "hour" = 0:23,
                            "ndvi" = ndvi_values_month, 
                            "canopy" = canopy_values, 
                            # "slope" = slope_values, 
                            "herby" = herby_values)

names(enviro_values) <- c("Data", "pres", "hour", "ndvi", "canopy", "herby") # "slope", 

# i = 1

buffalo_pres_values <- buffalo_CLR_year_harmonics %>% 
  filter(y == 1 & month == month_no) %>%  
  transmute(Data = "Presence", pres = y, hour = hour, ndvi = ndvi_scaled, canopy = canopy_scaled, herby = herby_scaled) # slope = slope_end, 

buffalo_background_values <- buffalo_CLR_year_harmonics %>% 
  filter(y == 0 & month == month_no) %>%  
  transmute(Data = "Random steps", pres = y, hour = hour, ndvi = ndvi_scaled, canopy = canopy_scaled, herby = herby_scaled) # slope = slope_end, 

enviro_buffalo_values <- rbind(enviro_values, buffalo_pres_values, buffalo_background_values)

# ggplot(enviro_buffalo_values) +
#   geom_density(aes(x = ndvi, fill = method), alpha = 0.5) +
#   geom_density(data = buffalo_CLR_year %>% filter(y == 1, year == 2019 & month == 1),
#                aes(x = ndvi_temporal), fill = "orange", alpha = 0.5) +
#   geom_density(data = buffalo_CLR_year %>% filter(y == 0, year == 2019 & month == 1),
#                aes(x = ndvi_temporal), linetype = "dashed", colour = "red", alpha = 0.5) +
#   theme_classic()

for(i in 0:23) {
print(ggplot() +
  geom_density(data = enviro_buffalo_values %>% filter(hour == i), aes(x = ndvi, fill = Data), alpha = 0.25) +
    scale_x_continuous(limits = c(-5, 5)) +
    ggtitle(label = paste0(i)) +
  theme_classic()) }

# ggplot() +
#   geom_density(data = enviro_buffalo_values, aes(x = canopy, fill = Data), alpha = 0.25) +
#   theme_classic()
# 
# ggplot() +
#   geom_density(data = enviro_buffalo_values, aes(x = herby, fill = Data), alpha = 0.25) +
#   theme_classic()


tab <- as.data.frame(prop.table(table(enviro_buffalo_values$canopy, enviro_buffalo_values$Data), 2))
names(tab) <- c("Canopy_cover", "Data", "Freq")

tab2 <- as.data.frame(prop.table(table(enviro_buffalo_values$herby, enviro_buffalo_values$Data), 2))
names(tab2) <- c("Herbaceous_veg", "Data", "Freq")

ggplot(data = tab, aes(x = Canopy_cover, y = Freq, fill = Data)) +
  geom_bar(stat = "identity", position = position_dodge(), alpha = 0.75) +
  theme_classic()

ggplot(data = tab2, aes(x = Herbaceous_veg, y = Freq, fill = Data)) +
  geom_bar(stat = "identity", position = position_dodge(), alpha = 0.75) +
  theme_classic()

```


# Predictions and cross-validation

Boyce index function

```{r}

ecospat.boyce2 <- function (fit, obs, nclass = 0, window.w = "default", res = 100, 
  PEplot = TRUE, rm.duplicate = TRUE, method = "spearman") 
{
  boycei <- function(interval, obs, fit) {
    pi <- sum(as.numeric(obs >= interval[1] & obs <= interval[2]))/length(obs)
    ei <- sum(as.numeric(fit >= interval[1] & fit <= interval[2]))/length(fit)
    return(round(pi/ei, 10))
  }
  if (inherits(fit, "RasterLayer")) {
    if (is.data.frame(obs) || is.matrix(obs)) {
      obs <- raster::extract(fit, obs)
    }
    fit <- getValues(fit)
    fit <- fit[!is.na(fit)]
    obs <- obs[!is.na(obs)]
  }
  mini <- min(fit, obs)
  maxi <- max(fit, obs)
  if (length(nclass) == 1) {
    if (nclass == 0) {
      if (window.w == "default") {
        window.w <- (max(fit) - min(fit))/10
      }
      vec.mov <- seq(from = mini, to = maxi - window.w, 
        by = (maxi - mini - window.w)/res)
      vec.mov[res + 1] <- vec.mov[res + 1] + 1
      interval <- cbind(vec.mov, vec.mov + window.w)
    }
    else {
      vec.mov <- seq(from = mini, to = maxi, by = (maxi - 
        mini)/nclass)
      interval <- cbind(vec.mov, c(vec.mov[-1], maxi))
    }
  }
  else {
    vec.mov <- c(mini, sort(nclass[!nclass > maxi | nclass < 
      mini]))
    interval <- cbind(vec.mov, c(vec.mov[-1], maxi))
  }
  f <- apply(interval, 1, boycei, obs, fit)
  to.keep <- which(f != "NaN")
  f <- f[to.keep]
  if (length(f) < 2) {
    b <- NA
  }
  else {
    r <- 1:length(f)
    if (rm.duplicate == TRUE) {
      r <- c(1:length(f))[f != c(f[-1], TRUE)]
    }
    b <- cor(f[r], vec.mov[to.keep][r], method = method)
  }
  HS <- apply(interval, 1, sum)/2
  if (length(nclass) == 1 & nclass == 0) {
    HS[length(HS)] <- HS[length(HS)] - 1
  }
  HS <- HS[to.keep]
  if (PEplot == TRUE) {
    plot(HS, f, xlab = "Habitat suitability", ylab = "Predicted/Expected ratio", 
      col = "grey", cex = 0.75)
    points(HS[r], f[r], pch = 19, cex = 0.75)
  }
  return(list(F.ratio = f, cor = round(b, 3), HS = HS))
}

```

Naive approach

```{r}

# ndvi_mean_wet <- terra::mean(ndvi_stack_cropped[[12 + months_wet]])
# plot(ndvi_mean_wet)

# naive_pred_50m <- terra::aggregate(naive_pred)
# naive_raster <- raster(naive_pred_50m)

naive_pred_stack <- c()
naive_pred_norm_stack <- c()
boyce_naive_list <- vector(mode = "list", length = 24)

for(i in 1:24) {
  
  # i = 1

# resources <- c(ndvi_stack_scaled[[12 + month_no]], 
#                # slope_scaled,
#                canopy_scaled,
#                herby_scaled)

# resources <- c(ndvi_mean_wet, 
#                # slope_scaled,
#                canopy_scaled,
#                herby_scaled)

resources <- c(ndvi_mean_wet,
               canopy_scaled_cropped,
               herby_scaled_cropped)

# ndvi
ndvi_lin <- resources[[1]] * hourly_coefs_2harms_quads$ndvi[[which(hourly_coefs_2harms_quads$hour == i)]]
# plot(ndvi_lin)
ndvi_quad <- (resources[[1]] ^ 2) * hourly_coefs_2harms_quads$ndvi_quad[[which(hourly_coefs_2harms_quads$hour == i)]]
# plot(ndvi_quad)
ndvi_pred <- ndvi_lin  + ndvi_quad
# plot(ndvi_pred)

# canopy cover 
canopy_lin <- resources[[2]] * hourly_coefs_2harms_quads$canopy[[which(hourly_coefs_2harms_quads$hour == i)]]
# plot(canopy_lin)
canopy_quad <- (resources[[2]] ^ 2) * hourly_coefs_2harms_quads$canopy_quad[[which(hourly_coefs_2harms_quads$hour == i)]]
# plot(canopy_quad)
canopy_pred <- canopy_lin + canopy_quad
# plot(canopy_pred)

# herby
herby_lin <- resources[[3]]
herby_pred <- herby_lin * hourly_coefs_2harms_quads$herby[[which(hourly_coefs_2harms_quads$hour == i)]]
# plot(herby_pred)

# combining
naive_pred <- exp(ndvi_pred + canopy_pred + herby_pred)
naive_pred_norm <- naive_pred / 
  global(naive_pred, fun = "sum", na.rm = TRUE)[[1]]

plot(naive_pred)
plot(naive_pred_norm)
points(as.numeric(buffalo_CLR_year %>%
                    filter(y == 1 & month %in% months_wet & hour == ifelse(i == 24, 0, i)) %>%
                    dplyr::select(x1) %>% unlist()),
       as.numeric(buffalo_CLR_year %>%
                    filter(y == 1 & month %in% months_wet & hour == ifelse(i == 24, 0, i)) %>%
                    dplyr::select(y1) %>% unlist()))

naive_pred_stack <- c(naive_pred_stack, naive_pred)
naive_pred_norm_stack <- c(naive_pred_norm_stack, naive_pred_norm)

# setting up the buffalo observation data for the relevant month

# buffalo_obs <- buffalo_CLR_year %>% 
#   filter(y == 1 & month == 1 & x1 > xmin & x1 < xmax & y1 > ymin & y1 < ymax) %>% 
#   transmute(x = x1 - xmin, y = y1 - ymin)

buffalo_obs <- buffalo_CLR_year_harmonics %>% 
  filter(y == 1 & month %in% months_wet & hour == ifelse(i == 24, 0, i)) %>% 
  transmute(x = x1, y = y1)

naive_raster <- raster(naive_pred_norm)
# naive_raster <- raster(naive_pred_cropped)

# plot(naive_pred)
# plot(naive_raster)

# plot(naive_cropped_raster[[1]])

# boyce_naive <- ecospat.boyce2(naive_cropped_raster[[1]], buffalo_obs,
#                               # method = "spearman"
#                               method = "pearson",
#                               # method = "kendall"
#                               )

boyce_naive <- ecospat.boyce2(naive_raster, buffalo_obs,
                              method = "spearman"
                              # method = "pearson",
                              # method = "kendall"
                              )

boyce_naive

boyce_naive_list[[i]] <- boyce_naive

}

# naive_raster_2harms <- naive_raster
# boyce_naive_list_2harms <- boyce_naive_list

naive_daily_2harms_quads_w_herby_wet <- naive_pred_stack
naive_norm_daily_2harms_quads_w_herby_wet <- naive_pred_norm_stack

boyce_naive_raster_daily_2harms_quads_w_herby_wet <- boyce_naive_list

terra::writeRaster(rast(naive_pred_stack), "mapping/naive_pred_stack_unnorm_daily_2harms_ndvi2_canopy2_herby_wet_20230525.tif")

```


```{r}

for(i in 1:24) {
  plot(naive_pred_stack[[i]])
}

for(i in 1:24) {
  # plot(naive_pred_stack[[i]])
  plot(naive_pred_stack[[i]])
  points(as.numeric(buffalo_CLR_year %>% filter(y == 1 & month %in% months_wet & hour == ifelse(i == 24, 0, i)) %>% dplyr::select(x1) %>% unlist()), 
       as.numeric(buffalo_CLR_year %>% filter(y == 1 & month %in% months_wet & hour == ifelse(i == 24, 0, i)) %>% dplyr::select(y1) %>% unlist()))
}

```


```{r}

spearman_cor <- c()

for(i in 1:24) {
  print(boyce_naive_list[[i]]$cor)
  spearman_cor[i] <- boyce_naive_list[[i]]$cor
}

mean(spearman_cor)
sd(spearman_cor)

```

```{r}

naive_uds <- rast(naive_pred_norm_stack)

# smaller 100 x 100 extent
xmin <- 30000
xmax <- 32500
ymin <- -1436000
ymax <- -1433500

# smaller 100 x 100 extent
xmin <- 27500
xmax <- 35000
ymin <- -1438500
ymax <- -1431000
# 
# # larger extent
# xmin <- 17500
# xmax <- 40000
# ymin <- -1445000
# ymax <- -1427500

crop_extent <- ext(xmin, xmax, ymin, ymax)

naive_ud_cropped <- terra::crop(naive_uds, crop_extent)
# ext(naive_ud_cropped) <- c(xmin - xmin, 
#                             xmax - xmin, 
#                             ymin - ymin, 
#                             ymax - ymin)

# naive_ud_cropped_50m <- terra::aggregate(naive_ud_cropped)
# plot(naive_ud_cropped_50m[[1]])

for(i in 1:24){
plot(naive_ud_cropped[[i]])
points(as.numeric(buffalo_CLR_year %>% 
                    filter(y == 1 & month %in% months_wet & hour == ifelse(i == 24, 0, i)) %>% 
                    dplyr::select(x1) %>% unlist()), 
       as.numeric(buffalo_CLR_year %>% 
                    filter(y == 1 & month %in% months_wet & hour == ifelse(i == 24, 0, i)) %>% 
                    dplyr::select(y1) %>% unlist()))
}

```


```{r}
# cross-validation with Boyce index

boyce_naive_cropped_list <- vector(mode = "list", length = 24)

for(i in 1:24) {
  
  # i = 1

buffalo_obs <- buffalo_CLR_year_harmonics %>% 
  filter(y == 1 & month %in% months_wet & hour == ifelse(i == 24, 0, i)) %>% 
  transmute(x = x1, y = y1)

naive_raster <- raster(naive_ud_cropped[[i]])

boyce_naive <- ecospat.boyce2(naive_raster, buffalo_obs,
                              method = "spearman"
                              # method = "pearson",
                              # method = "kendall"
                              )

boyce_naive

boyce_naive_cropped_list[[i]] <- boyce_naive

}


```


notes:

- for ndvi and canopy with quadratics the predictions are really bad in the night - is this a statistical artifact or do they respond to something at night that we aren't included in the model..?


# With 3 pairs of harmonics 

```{r three harmonics}

formula_twostep <- y ~ 
  
  ndvi_scaled +
  hour_s1:ndvi_scaled +
  hour_s2:ndvi_scaled +
  hour_s3:ndvi_scaled +
  hour_c1:ndvi_scaled +
  hour_c2:ndvi_scaled +
  hour_c3:ndvi_scaled +
  
  ndvi_2 +
  hour_s1:ndvi_2 +
  hour_s2:ndvi_2 +
  hour_s3:ndvi_2 +
  hour_c1:ndvi_2 +
  hour_c2:ndvi_2 +
  hour_c3:ndvi_2 +

  canopy_scaled +
  hour_s1:canopy_scaled +
  hour_s2:canopy_scaled +
  hour_s3:canopy_scaled +
  hour_c1:canopy_scaled +
  hour_c2:canopy_scaled +
  hour_c3:canopy_scaled +
  
  canopy_2 +
  hour_s1:canopy_2 +
  hour_s2:canopy_2 +
  hour_s3:canopy_2 +
  hour_c1:canopy_2 +
  hour_c2:canopy_2 +
  hour_c3:canopy_2 +
  
  herby_scaled +
  hour_s1:herby_scaled +
  hour_s2:herby_scaled +
  hour_s3:herby_scaled +
  hour_c1:herby_scaled +
  hour_c2:herby_scaled +
  hour_c3:herby_scaled +
  
  sl +
  hour_s1:sl +
  hour_s2:sl +
  hour_s3:sl +
  hour_c1:sl +
  hour_c2:sl +
  hour_c3:sl +
  
  log_sl +
  hour_s1:log_sl +
  hour_s2:log_sl +
  hour_s3:log_sl +
  hour_c1:log_sl +
  hour_c2:log_sl +
  hour_c3:log_sl +
  
  cos_ta +
  hour_s1:cos_ta +
  hour_s2:cos_ta +
  hour_s3:cos_ta +
  hour_c1:cos_ta +
  hour_c2:cos_ta +
  hour_c3:cos_ta +
  
  strata(step_id) +
  cluster(id)

```

Fitting the model

```{r twostep model fit}

month_no <- 3
buffalo_model_data <- buffalo_CLR_year_harmonics %>% dplyr::filter(month == month_no)

# months_wet <- c(1:4, 11, 12)
# buffalo_model_data_wet <- buffalo_CLR_year_harmonics %>% dplyr::filter(month == month_no)
# 
# month_no <- 3
# buffalo_model_data_dry <- buffalo_CLR_year_harmonics %>% dplyr::filter(month == month_no)

tic()
model_twostep <- Ts.estim(formula = formula_twostep,
         data = buffalo_model_data,
         all.m.1 = TRUE,
         D = "UN(1)",
         itermax = 10000) # default = 2000
toc()

# model_twostep_2harms <- model_twostep
# model_twostep_2harms_w_herby_quads <- model_twostep
model_twostep_3harms_w_herby_quads <- model_twostep
# model_twostep_3harms <- model_twostep
# model_twostep <- model_twostep_3harms

```

Summary of model fit

```{r two step summary}

model_twostep
# summary(model_twostep)
# print(model_twostep)

```

Reconstructing coefficients with two harmonics with quadratics

```{r}

hour <- seq(0,24,0.1)
# hour <- seq(1,24,1)

hour_harmonics_df <- data.frame("hour_s1" = sin(2*pi*hour/24),
                                "hour_s2" = sin(4*pi*hour/24),
                                "hour_s3" = sin(6*pi*hour/24),
                                # "hour_s4" = sin(8*pi*hour/24),
                                "hour_c1" = cos(2*pi*hour/24),
                                "hour_c2" = cos(4*pi*hour/24),
                                "hour_c3" = cos(6*pi*hour/24))
                                # "hour_c4" = cos(8*pi*hour/24))

# plot(x = hour, y = hour_harmonics_df$hour_s1, type = "l")

coef_names <- names(model_twostep$beta)[1:8] # only get linear terms

harmonic_coefs_list <- vector(mode = "list", length = length(coef_names))

for(i in 1:length(coef_names)) {
harmonic_coefs_list[[i]] <- c(model_twostep$beta[which(names(model_twostep$beta) == paste0(coef_names[i]))],
                              model_twostep$beta[which(names(model_twostep$beta) == paste0(coef_names[i], ":hour_s1"))],
                               model_twostep$beta[which(names(model_twostep$beta) == paste0(coef_names[i], ":hour_s2"))],
                               model_twostep$beta[which(names(model_twostep$beta) == paste0(coef_names[i], ":hour_s3"))],
                               model_twostep$beta[which(names(model_twostep$beta) == paste0(coef_names[i], ":hour_c1"))],
                               model_twostep$beta[which(names(model_twostep$beta) == paste0(coef_names[i], ":hour_c2"))],
                               model_twostep$beta[which(names(model_twostep$beta) == paste0(coef_names[i], ":hour_c3"))])
}


for(i in 1:length(coef_names)) {
plot(x = hour, 
     y = (harmonic_coefs_list[[i]][1] + 
            as.matrix(hour_harmonics_df) %*% 
            harmonic_coefs_list[[i]][2:7]),  
     main = paste0(coef_names[i]),
     ylab = "Temporally varying coefficient",
     type = "l")
}


hourly_coefs_3harms_quads <- data.frame("hour" = hour,
                                  "ndvi" = harmonic_coefs_list[[1]][1] + as.matrix(hour_harmonics_df) %*% harmonic_coefs_list[[1]][2:7],
                                  "ndvi_quad" = harmonic_coefs_list[[2]][1] + as.matrix(hour_harmonics_df) %*% harmonic_coefs_list[[2]][2:7],
                                  "canopy" = harmonic_coefs_list[[3]][1] + as.matrix(hour_harmonics_df) %*% harmonic_coefs_list[[3]][2:7],
                                  "canopy_quad" = harmonic_coefs_list[[4]][1] + as.matrix(hour_harmonics_df) %*% harmonic_coefs_list[[4]][2:7],
                                  "herby" = harmonic_coefs_list[[5]][1] + as.matrix(hour_harmonics_df) %*% harmonic_coefs_list[[5]][2:7],
                                  "sl" = harmonic_coefs_list[[6]][1] + as.matrix(hour_harmonics_df) %*% harmonic_coefs_list[[6]][2:7],
                                  "log_sl" = harmonic_coefs_list[[7]][1] + as.matrix(hour_harmonics_df) %*% harmonic_coefs_list[[7]][2:7],
                                  "cos_ta" = harmonic_coefs_list[[8]][1] + as.matrix(hour_harmonics_df) %*% harmonic_coefs_list[[8]][2:7])


# there's surely a way to loop this

# i = 1
# hourly_coefs_2harms_quads <- data.frame("hour" = hour,
#                                   paste0(coef_names[i]) = harmonic_coefs_list[[i]][1] + 
#                                     as.matrix(hour_harmonics_df) %*% harmonic_coefs_list[[i]][2:5])

```

Reconstructing the Gamma and von Mises distributions from the tentative distributions (from Fieberg et al 2021: Appendix C)

```{r}

# for individuals
# movement_parameters <- read_csv("outputs/buffalo_parametric_indv_movement_params_20230208.csv")
# movement_parameters_year <- movement_parameters %>% filter(id %in% buffalo_year_ids)

# for the population
# gamma$params$shape # 0.438167
# gamma$params$scale # 534.3507
# vonmises$params$kappa # 0.1848126

tentative_shape <- 0.438167
tentative_scale <- 534.3507
tentative_kappa <- 0.1848126

hourly_coefs_3harms_quads <- hourly_coefs_3harms_quads %>% mutate(shape = tentative_shape + log_sl,
                             scale = 1/((1/tentative_scale) - sl),
                             kappa = tentative_kappa + cos_ta)

# write_csv(harmonic_coefs_df, "outputs/harmonic_coefs_df_with_movement_params_ndvi_canopy_quads_20230519.csv")

# turning into a long data frame
hourly_coefs_3harms_quads_long <- pivot_longer(hourly_coefs_3harms_quads, cols = !1, names_to = "coef")
head(hourly_coefs_3harms_quads_long)

# write_csv(harmonic_coefs, "outputs/harmonic_coefs_df_long_with_movement_params_ndvi_canopy_quads_20230519.csv")

```

```{r}

coefs <- unique(hourly_coefs_3harms_quads_long$coef)
# coef_titles <- c("NDVI", "Slope", "Herbaceous vegetation", "Canopy cover", "Step length", "log(Step length)", "cos(Turning angle)")

ggplot() +
    geom_path(data = hourly_coefs_3harms_quads_long %>%
                filter(coef %in% unique(hourly_coefs_3harms_quads_long$coef)[1:5]),
              aes(x = hour, y = value, colour = coef)) +
    geom_hline(yintercept = 0, linetype = "dashed") +
    scale_y_continuous(expression(Time-varying~parameter~values~beta)) +
    scale_x_continuous("Hour of the day") +
    scale_color_discrete("Estimate") +
    # ggtitle(coef_titles[i]) +
    theme_classic() +
    theme(legend.position = "bottom")

# ggsave(paste("outputs/plots/clr_fitting/clr_3harmonics_all_quads_20230519.png", sep = ""),
#   width=150, height=90, units="mm", dpi = 300)
# ggsave(paste("outputs/plots/clr_fitting/clr_harmonic_all_pres_20230208.png", sep = ""),
#   width=300, height=180, units="mm", dpi = 300)

ggplot() +
    geom_path(data = hourly_coefs_3harms_quads_long %>% 
                filter(coef %in% unique(hourly_coefs_3harms_quads_long$coef)[c(9,11)]), 
              aes(x = hour, y = value, colour = coef)) +
    geom_hline(yintercept = 0, linetype = "dashed") +
    scale_y_continuous(expression(beta)) +
    # scale_x_continuous(breaks = 0:24) +
    scale_color_discrete("Estimate") +
    # ggtitle(coef_titles[i]) +
    theme_classic() +
    theme(legend.position = "bottom")

ggplot() +
    geom_path(data = hourly_coefs_3harms_quads_long %>% 
                filter(coef %in% unique(hourly_coefs_3harms_quads_long$coef)[10]), 
              aes(x = hour, y = value, colour = coef)) +
    geom_hline(yintercept = 0, linetype = "dashed") +
    scale_y_continuous(expression(beta)) +
    # scale_x_continuous(breaks = 0:24) +
    scale_color_discrete("Estimate") +
    # ggtitle(coef_titles[i]) +
    theme_classic() +
    theme(legend.position = "bottom")

```


```{r}

x <- seq(-5,5,0.1)
y <- (0.4 * x) + (-0.15 * x^2)

plot(x, y, xlim = c(-5,5), ylim = c(-5, 5))

```



```{r}

x <- seq(0, 1000, length = 500)

# with tentative parameters
plot(x, dgamma(x, shape = tentative_shape, scale = tentative_scale), type = "l")

temporal_movement_params <- hourly_coefs_2harms_quads %>% dplyr::select(c("hour", "shape", "scale", "kappa"))
# write_csv(temporal_movement_params, "outputs/temporal_movement_params_CLR_20230210.csv")

ggplot() +
  stat_function(fun = dgamma, args = list(shape = tentative_shape, scale = tentative_scale)) +
  scale_x_continuous(limits = c(0,1000), breaks = seq(0,1000,100)) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  theme_classic()

# subset <- temporal_movement_params %>% filter(month < 1)

# ggplot(subset) +
#   stat_function(fun = dgamma, args = list(shape = shape, scale = scale)) +
#   scale_x_continuous(limits = c(0,1000), breaks = seq(0,1000,100)) +
#   geom_hline(yintercept = 0, linetype = "dashed") +
#   theme_classic()

```


# Generating predictions

Use the habitat layer script to import habitat layers

Checking distributions of covariates vs used and random locations

```{r}

ndvi_values_month <- values(ndvi_stack_scaled[[12 + month_no]])
canopy_values <- values(canopy_scaled)
# slope_values <- values(slope_scaled)
herby_values <- values(herby_scaled)

enviro_values <- data.frame("Data" = "Environmental", 
                            "pres" = 1,
                            "hour" = 0:23,
                            "ndvi" = ndvi_values_month, 
                            "canopy" = canopy_values, 
                            # "slope" = slope_values, 
                            "herby" = herby_values)

names(enviro_values) <- c("Data", "pres", "hour", "ndvi", "canopy", "herby") # "slope", 

# i = 1

buffalo_pres_values <- buffalo_CLR_year_harmonics %>% 
  filter(y == 1 & month == month_no) %>%  
  transmute(Data = "Presence", pres = y, hour = hour, ndvi = ndvi_scaled, canopy = canopy_scaled, herby = herby_scaled) # slope = slope_end, 

buffalo_background_values <- buffalo_CLR_year_harmonics %>% 
  filter(y == 0 & month == month_no) %>%  
  transmute(Data = "Random steps", pres = y, hour = hour, ndvi = ndvi_scaled, canopy = canopy_scaled, herby = herby_scaled) # slope = slope_end, 

enviro_buffalo_values <- rbind(enviro_values, buffalo_pres_values, buffalo_background_values)

# ggplot(enviro_buffalo_values) +
#   geom_density(aes(x = ndvi, fill = method), alpha = 0.5) +
#   geom_density(data = buffalo_CLR_year %>% filter(y == 1, year == 2019 & month == 1),
#                aes(x = ndvi_temporal), fill = "orange", alpha = 0.5) +
#   geom_density(data = buffalo_CLR_year %>% filter(y == 0, year == 2019 & month == 1),
#                aes(x = ndvi_temporal), linetype = "dashed", colour = "red", alpha = 0.5) +
#   theme_classic()

for(i in 0:23) {
print(ggplot() +
  geom_density(data = enviro_buffalo_values %>% filter(hour == i), aes(x = ndvi, fill = Data), alpha = 0.25) +
    scale_x_continuous(limits = c(-5, 5)) +
    ggtitle(label = paste0(i)) +
  theme_classic()) }

# ggplot() +
#   geom_density(data = enviro_buffalo_values, aes(x = canopy, fill = Data), alpha = 0.25) +
#   theme_classic()
# 
# ggplot() +
#   geom_density(data = enviro_buffalo_values, aes(x = herby, fill = Data), alpha = 0.25) +
#   theme_classic()


tab <- as.data.frame(prop.table(table(enviro_buffalo_values$canopy, enviro_buffalo_values$Data), 2))
names(tab) <- c("Canopy_cover", "Data", "Freq")

tab2 <- as.data.frame(prop.table(table(enviro_buffalo_values$herby, enviro_buffalo_values$Data), 2))
names(tab2) <- c("Herbaceous_veg", "Data", "Freq")

ggplot(data = tab, aes(x = Canopy_cover, y = Freq, fill = Data)) +
  geom_bar(stat = "identity", position = position_dodge(), alpha = 0.75) +
  theme_classic()

ggplot(data = tab2, aes(x = Herbaceous_veg, y = Freq, fill = Data)) +
  geom_bar(stat = "identity", position = position_dodge(), alpha = 0.75) +
  theme_classic()

```


# Predictions and cross-validation

Boyce index function

```{r}

ecospat.boyce2 <- function (fit, obs, nclass = 0, window.w = "default", res = 100, 
  PEplot = TRUE, rm.duplicate = TRUE, method = "spearman") 
{
  boycei <- function(interval, obs, fit) {
    pi <- sum(as.numeric(obs >= interval[1] & obs <= interval[2]))/length(obs)
    ei <- sum(as.numeric(fit >= interval[1] & fit <= interval[2]))/length(fit)
    return(round(pi/ei, 10))
  }
  if (inherits(fit, "RasterLayer")) {
    if (is.data.frame(obs) || is.matrix(obs)) {
      obs <- raster::extract(fit, obs)
    }
    fit <- getValues(fit)
    fit <- fit[!is.na(fit)]
    obs <- obs[!is.na(obs)]
  }
  mini <- min(fit, obs)
  maxi <- max(fit, obs)
  if (length(nclass) == 1) {
    if (nclass == 0) {
      if (window.w == "default") {
        window.w <- (max(fit) - min(fit))/10
      }
      vec.mov <- seq(from = mini, to = maxi - window.w, 
        by = (maxi - mini - window.w)/res)
      vec.mov[res + 1] <- vec.mov[res + 1] + 1
      interval <- cbind(vec.mov, vec.mov + window.w)
    }
    else {
      vec.mov <- seq(from = mini, to = maxi, by = (maxi - 
        mini)/nclass)
      interval <- cbind(vec.mov, c(vec.mov[-1], maxi))
    }
  }
  else {
    vec.mov <- c(mini, sort(nclass[!nclass > maxi | nclass < 
      mini]))
    interval <- cbind(vec.mov, c(vec.mov[-1], maxi))
  }
  f <- apply(interval, 1, boycei, obs, fit)
  to.keep <- which(f != "NaN")
  f <- f[to.keep]
  if (length(f) < 2) {
    b <- NA
  }
  else {
    r <- 1:length(f)
    if (rm.duplicate == TRUE) {
      r <- c(1:length(f))[f != c(f[-1], TRUE)]
    }
    b <- cor(f[r], vec.mov[to.keep][r], method = method)
  }
  HS <- apply(interval, 1, sum)/2
  if (length(nclass) == 1 & nclass == 0) {
    HS[length(HS)] <- HS[length(HS)] - 1
  }
  HS <- HS[to.keep]
  if (PEplot == TRUE) {
    plot(HS, f, xlab = "Habitat suitability", ylab = "Predicted/Expected ratio", 
      col = "grey", cex = 0.75)
    points(HS[r], f[r], pch = 19, cex = 0.75)
  }
  return(list(F.ratio = f, cor = round(b, 3), HS = HS))
}

```

Naive approach

```{r}

naive_pred_stack <- c()
boyce_naive_list <- vector(mode = "list", length = 24)

for(i in 1:24) {
  
  # i = 1

resources <- c(ndvi_stack_scaled[[12 + month_no]], 
               # slope_scaled,
               canopy_scaled,
               herby_scaled)

# ndvi
ndvi_lin <- resources[[1]]
ndvi_lin <- ndvi_lin * hourly_coefs_3harms_quads$ndvi[[which(hourly_coefs_3harms_quads$hour == i)]]
# plot(ndvi_lin)
ndvi_quad <- resources[[1]]
ndvi_quad <- (ndvi_quad ^ 2) * hourly_coefs_3harms_quads$ndvi_quad[[which(hourly_coefs_3harms_quads$hour == i)]]
# plot(ndvi_quad)
ndvi_pred <- ndvi_lin  + ndvi_quad
plot(ndvi_pred)

# canopy cover 
canopy_lin <- resources[[2]]
canopy_lin <- canopy_lin * hourly_coefs_3harms_quads$canopy[[which(hourly_coefs_3harms_quads$hour == i)]]
# plot(canopy_lin)
canopy_quad <- resources[[2]]
canopy_quad <- (canopy_quad ^ 2) * hourly_coefs_3harms_quads$canopy_quad[[which(hourly_coefs_3harms_quads$hour == i)]]
# plot(canopy_quad)
canopy_pred <- canopy_lin + canopy_quad
plot(canopy_pred)

# herby
herby_lin <- resources[[3]]
herby_pred <- herby_lin * hourly_coefs_3harms_quads$herby[[which(hourly_coefs_3harms_quads$hour == i)]]
plot(herby_pred)

# combining
naive_pred <- exp(ndvi_pred + canopy_pred + herby_pred) / 
  global(exp(ndvi_pred + canopy_pred + herby_pred), fun = "sum", na.rm = TRUE)[[1]]

plot(naive_pred)
plot(naive_pred)
points(as.numeric(buffalo_CLR_year %>% 
                    filter(y == 1 & month == month_no & hour == ifelse(i == 24, 0, i)) %>% 
                    dplyr::select(x1) %>% unlist()), 
       as.numeric(buffalo_CLR_year %>% 
                    filter(y == 1 & month == month_no & hour == ifelse(i == 24, 0, i)) %>% 
                    dplyr::select(y1) %>% unlist()))

naive_pred_stack <- c(naive_pred_stack, naive_pred)

# setting up the buffalo observation data for the relevant month

# buffalo_obs <- buffalo_CLR_year %>% 
#   filter(y == 1 & month == 1 & x1 > xmin & x1 < xmax & y1 > ymin & y1 < ymax) %>% 
#   transmute(x = x1 - xmin, y = y1 - ymin)

buffalo_obs <- buffalo_CLR_year %>% 
  filter(y == 1 & month == month_no & hour == ifelse(i == 24, 0, i)) %>% 
  transmute(x = x1, y = y1)

naive_raster <- raster(naive_pred)
# naive_raster <- raster(naive_pred_cropped)

# plot(naive_pred)
# plot(naive_raster)

# plot(naive_cropped_raster[[1]])

# boyce_naive <- ecospat.boyce2(naive_cropped_raster[[1]], buffalo_obs,
#                               # method = "spearman"
#                               method = "pearson",
#                               # method = "kendall"
#                               )

boyce_naive <- ecospat.boyce2(naive_raster, buffalo_obs,
                              method = "spearman"
                              # method = "pearson",
                              # method = "kendall"
                              )

boyce_naive_list[[i]] <- boyce_naive

boyce_naive

}

# naive_raster_2harms <- naive_raster
# boyce_naive_list_2harms <- boyce_naive_list

naive_raster_daily_3harms_quads_w_herby <- naive_raster
boyce_naive_raster_daily_3harms_quads_w_herby <- boyce_naive_list

```


```{r}

for(i in 1:24) {
  plot(naive_raster_daily_3harms_quads_w_herby[[i]])
}

for(i in 1:24) {
  # plot(naive_pred_stack[[i]])
  plot(naive_raster_daily_3harms_quads_w_herby[[i]])
  points(as.numeric(buffalo_CLR_year %>% filter(y == 1 & month == month_no & hour == ifelse(i == 24, 0, i)) %>% dplyr::select(x1) %>% unlist()), 
       as.numeric(buffalo_CLR_year %>% filter(y == 1 & month == month_no & hour == ifelse(i == 24, 0, i)) %>% dplyr::select(y1) %>% unlist()))
}

```



```{r}

spearman_cor <- c()

for(i in 1:24) {
  print(boyce_naive_raster_daily_3harms_quads_w_herby[[i]]$cor)
  spearman_cor[i] <- boyce_naive_raster_daily_3harms_quads_w_herby[[i]]$cor
}

mean(spearman_cor)
sd(spearman_cor)

```


notes:

- for ndvi and canopy with quadratics the predictions are really bad in the night - is this a statistical artifact or do they respond to something at night that we aren't included in the model..?