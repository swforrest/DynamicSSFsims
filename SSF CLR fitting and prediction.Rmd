---
title: "SSF CLR fitting and prediction"
author: "Scott Forrest"
date: "`r Sys.Date()`"
output: html_document
editor_options: 
  chunk_output_type: inline
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


Import packages

```{r message = FALSE}

options(scipen=999)

# install.packages("dplyr")
# install.packages("dplyr")

library(tidyverse)

packages <- c("amt", "lubridate", "mgcv", "survival", "terra", "raster", "tictoc", 
              "RColorBrewer", "patchwork", "ecospat", "ggmap", "basemaps", "mapedit", 
              "sf", "ggpubr", "circular")

walk(packages, require, character.only = T)

```


Import buffalo telemetry data.

```{r message = FALSE}

# buffalo_CLR <- read_csv(file = "outputs/buffalo_parametric_indv_covs_20230208.csv")
# using the population estimate as the TENTATIVE distribution will make it easier to estimate the weighted mean estimate of the movement kernel
buffalo_data <- read_csv(file = "outputs/buffalo_parametric_popn_covs_20230208.csv")

unique(buffalo_data$id)

# scaling_mean <- mean(values(ndvi_projected[[7]], na.rm = TRUE)) # 0.4054526 for July 2018
# scaling_sd <- sd(values(ndvi_projected[[7]], na.rm = TRUE)) # 0.1113644 for July 2018

buffalo_CLR <- buffalo_data %>% 
  mutate(id_num = as.numeric(factor(id)), 
         step_id = step_id_, 
         x1 = x1_, x2 = x2_, 
         y1 = y1_, y2 = y2_, 
         t1 = t1_, 
         t1_rounded = round_date(buffalo_data$t1_, "hour"), 
         t2 = t2_, 
         yday = yday(t1_),
         sl = sl_, log_sl = log_sl_, 
         ta = ta_, cos_ta = cos_ta_,
         year = year(t1_), 
         month = month(t1_), 
         # month_factor = factor(month(t1_)),
         hour = hour(t1_),
         # hour_factor = factor(hour),
         # day = day(t1_),
         # day_factor = factor(day(t1_)),
         # step_id_factor = factor(step_id_),
         ndvi_scaled = scale(ndvi_temporal),
         ndvi_scaled_raster = ((ndvi_temporal - 0.4054526) / 0.1113644),
         canopy_01 = canopy_cover/100,
         herby_scaled = scale(veg_herby),
         canopy_scaled = scale(canopy_01),
         elev_scaled = scale(DEM_H_end),
         elev_delta_scaled = scale(elev_delta),
         elev_log_scaled = scale(elev_log),
         slope_scaled = scale(slope_end),
         month_s1 = sin(2*pi*month/12),
         month_s2 = sin(4*pi*month/12),
         month_s3 = sin(6*pi*month/12),
         month_s4 = sin(8*pi*month/12),
         month_c1 = cos(2*pi*month/12),
         month_c2 = cos(4*pi*month/12),
         month_c3 = cos(6*pi*month/12),
         month_c4 = cos(8*pi*month/12),
         yday_s1 = sin(2*pi*yday/365),
         yday_s2 = sin(4*pi*yday/365),
         yday_s3 = sin(6*pi*yday/365),
         yday_s4 = sin(8*pi*yday/365),
         yday_c1 = cos(2*pi*yday/365),
         yday_c2 = cos(4*pi*yday/365),
         yday_c3 = cos(6*pi*yday/365),
         yday_c4 = cos(8*pi*yday/365)) %>%
  drop_na(c(ndvi_temporal, veg_herby, canopy_01, sl_)) %>% 
  dplyr::select(!(burst_:case_))

```


Determining how many individuals have at least 1 year of data

```{r}

buffalo_CLR %>% ggplot(aes(x = t1, y = factor(id), colour = factor(id))) +
  geom_point(alpha = 0.1) +
  scale_y_discrete("Buffalo ID") +
  scale_x_datetime("Date") +
  scale_colour_viridis_d() +
  theme_bw() +
  theme(legend.position = "none")

buffalo_CLR %>% dplyr::group_by(id) %>%  
  summarise(min_time = min(t1), max_time = max(t1),
            min_x = min(x2), max_x = max(x2),
            min_y = min(y2), max_y = max(y2))

```


```{r}

buffalo_CLR %>% filter(y == 1 & id == 2005) %>% ggplot(aes(x = x1, y = y1, colour = t1)) +
  geom_point(alpha = 0.5) +
  geom_path(alpha = 0.5) +
  coord_equal() +
  scale_y_continuous("Northing (m)") +
  scale_x_continuous("Easting (m)") +
  scale_colour_datetime() +
  theme_bw() +
  theme(legend.position = "none")

ggsave("outputs/plots/buffalo_data_id2005_20230309.png",
       width=150, height=90, units="mm", dpi = 300)

```


Filtering by animals that have more than a year of data

```{r}

buffalo_year_ids <- c(2005, 2014, 2018, 2022, 2024, 2154, 2158, 2327, 2354, 2387)
buffalo_CLR_year <- buffalo_CLR %>% filter(id %in% buffalo_year_ids)
unique(buffalo_CLR_year$id)

```

Movement parameters from random sampling

```{r}

# gamma <- fit_distr(buffalo_all_steps_by_burst$sl_, "gamma")$params$shape
# vonmises <- fit_distr(buffalo_all_steps_by_burst$ta_, "vonmises")

# population
gamma$params$shape # 0.438167
gamma$params$scale # 534.3507
vonmises$params$kappa # 0.1848126
vonmises$params$mu # 0

movement_parameters <- read_csv("outputs/buffalo_parametric_indv_movement_params_20230208.csv")

movement_parameters_year <- movement_parameters %>% filter(id %in% buffalo_year_ids)

```



```{r}

# x <- seq(0, 12, length.out = 1000)
# 
# s1 <- sin((2 * pi * x) / 12)
# s2 <- sin((4 * pi * x) / 12)
# c1 <- cos((2 * pi * x) / 12)
# c2 <- cos((4 * pi * x) / 12)
# 
# harmonics <-data.frame("x" = rep(x, 4), 
#            "Harmonics" = rep(c("s1", "s2", "c1", "c2"), each = 1000),
#            "values" = c(s1, s2, c1, c2))
# 
# a <- ggplot(harmonics %>% filter(Harmonics == "s1")) +
#   geom_line(aes(x = x, y = values, colour = Harmonics)) +
#   geom_hline(yintercept = 0, linetype = "dashed") +
#   scale_y_continuous("Magnitude of the coefficient") +
#   scale_x_continuous("Month", breaks = 1:12) +
#   scale_colour_viridis_d() +
#   theme_classic()
# 
# b <- ggplot(harmonics %>% filter(Harmonics == "c1")) +
#   geom_line(aes(x = x, y = values, colour = Harmonics)) +
#   geom_hline(yintercept = 0, linetype = "dashed") +
#   scale_y_continuous("Magnitude of the coefficient") +
#   scale_x_continuous("Month", breaks = 1:12) +
#   scale_colour_viridis_d() +
#   theme_classic()
# 
# c <- ggplot(harmonics %>% filter(Harmonics == "s2")) +
#   geom_line(aes(x = x, y = values, colour = Harmonics)) +
#   geom_hline(yintercept = 0, linetype = "dashed") +
#   scale_y_continuous("Magnitude of the coefficient") +
#   scale_x_continuous("Month", breaks = 1:12) +
#   scale_colour_viridis_d() +
#   theme_classic()
# 
# d <- ggplot(harmonics %>% filter(Harmonics == "c2")) +
#   geom_line(aes(x = x, y = values, colour = Harmonics)) +
#   geom_hline(yintercept = 0, linetype = "dashed") +
#   scale_y_continuous("Magnitude of the coefficient") +
#   scale_x_continuous("Month", breaks = 1:12) +
#   scale_colour_viridis_d() +
#   theme_classic()
# 
# e <- ggplot(harmonics) +
#   geom_line(aes(x = x, y = values, colour = Harmonics)) +
#   geom_hline(yintercept = 0, linetype = "dashed") +
#   scale_y_continuous("Magnitude of the coefficient") +
#   scale_x_continuous("Month", breaks = 1:12) +
#   scale_colour_viridis_d() +
#   theme_classic()
# 
# plots <- c(a,b,c,d,e)
# 
# ggsave("outputs/plots/harmonic_plots_b_20230309.png",
#                      plot = b,
#   width=150, height=90, units="mm", dpi = 300)

```


## Conditional logistic regression model

```{r}

formula_clr <- y ~ 
               
               ndvi_scaled +
               yday_s1:ndvi_scaled +
               yday_s2:ndvi_scaled +
               yday_c1:ndvi_scaled +
               yday_c2:ndvi_scaled +
  
               I(ndvi_scaled^2) +
               yday_s1:I(ndvi_scaled^2) +
               yday_s2:I(ndvi_scaled^2) +
               yday_c1:I(ndvi_scaled^2) +
               yday_c2:I(ndvi_scaled^2) +
               
               # WOFS05_dist_scaled +
               # month_s1:WOFS05_dist_scaled +
               # month_s2:WOFS05_dist_scaled +
               # month_c1:WOFS05_dist_scaled +
               # month_c2:WOFS05_dist_scaled +
               # 
               # I(WOFS05_dist_scaled^2) +
               # month_s1:I(WOFS05_dist_scaled^2) +
               # month_s2:I(WOFS05_dist_scaled^2) +
               # month_c1:I(WOFS05_dist_scaled^2) +
               # month_c2:I(WOFS05_dist_scaled^2) +
               
               # WOFS80_dist_scaled +
               # I(WOFS80_dist_scaled^2) +
               
               # elev_log +
               # month_s1:elev_log +
               # month_s2:elev_log +
               # month_c1:elev_log +
               # month_c2:elev_log +
               
               # slope_scaled +
               # month_s1:slope_scaled +
               # month_s2:slope_scaled +
               # month_c1:slope_scaled +
               # month_c2:slope_scaled +
               
               # herby_scaled +
               # yday_s1:herby_scaled +
               # yday_s2:herby_scaled +
               # yday_c1:herby_scaled +
               # yday_c2:herby_scaled +
               
               canopy_scaled +
               yday_s1:canopy_scaled +
               yday_s2:canopy_scaled +
               yday_c1:canopy_scaled +
               yday_c2:canopy_scaled +
  
               I(canopy_scaled^2) +
               yday_s1:I(canopy_scaled^2) +
               yday_s2:I(canopy_scaled^2) +
               yday_c1:I(canopy_scaled^2) +
               yday_c2:I(canopy_scaled^2) +
               
               sl +
               yday_s1:sl +
               yday_s2:sl +
               yday_c1:sl +
               yday_c2:sl +
               
               log_sl +
               yday_s1:log_sl +
               yday_s2:log_sl +
               yday_c1:log_sl +
               yday_c2:log_sl +
               
               cos_ta +
               yday_s1:cos_ta +
               yday_s2:cos_ta +
               yday_c1:cos_ta +
               yday_c2:cos_ta +
               
               strata(step_id)

```


Looping over all individuals

```{r}

clogit_model_list <- list()

for(i in 1:length(unique(buffalo_CLR_year$id))) {
  
  subset_id <- unique(buffalo_CLR_year$id)[i]
  buffalo_subset <- buffalo_CLR %>% filter(id == subset_id)

  clogit_model_list[[i]] <- fit_clogit(buffalo_subset, formula = formula_clr)
  # print(summary(clogit_model))
  print(AIC(clogit_model_list[[i]]))

}

summary(clogit_model_list[[1]])

# save(clogit_model_list, file = "workspace images/clr_models_ndvi_slope_canopy_herby_2_harmonics_20230209.rds")

```



```{r}

for(i in 1:10) print(summary(clr_models[[i]]))

```



```{r}

# coefs_df <- data.frame("index" = 1:length(clogit_model_list[[1]]$model$coefficients), 
#                        "coef" = names(clogit_model_list[[1]]$model$coefficients), 
#                        "value" = clogit_model_list[[1]]$model$coefficients)


coefs_df_function <- function(clogit_model) {
  
  return(data.frame("index" = 1:length(clogit_model$model$coefficients), 
                    "coef" = names(clogit_model$model$coefficients), 
                    "value" = clogit_model$model$coefficients, 
                    "se" = sqrt(diag(clogit_model$model$var)),
                    "weight" = 1/diag(clogit_model$model$var)))
}

clogit_model_coef_list <- map(clogit_model_list, coefs_df_function)

buffalo_ids <- unique(buffalo_CLR_year$id)

clogit_coefs <- do.call(rbind, clogit_model_coef_list)
clogit_coefs$id <- rep(buffalo_ids, each = length(clogit_model_list[[1]]$model$coefficients))
clogit_coefs

# clogit_coefs %>% filter(coef == "ndvi_temporal")
clogit_coefs %>% filter(coef == "ndvi_scaled")
clogit_coefs %>% filter(coef == "I(ndvi_scaled^2)")
clogit_coefs %>% filter(coef == "canopy_scaled")
clogit_coefs %>% filter(coef == "I(canopy_scaled^2)")
# clogit_coefs %>% filter(coef == "slope_scaled")

# mean(x = ndvi_lin_df$coefs)
# weighted.mean(x = ndvi_lin_df$coefs, w = ndvi_lin_df$weights)
# 
# pivot_longer(clogit_coefs, cols = coef, names_to = c("coef", "se"))

```


Calculating WEIGHTED arithmetic mean coefficient values across months 

Loop to calculate means and weighted means 

```{r}

coef <- c()
mean <- c()
w_mean <- c()

for(i in 1:length(unique(clogit_coefs$coef))) {
  
  # i <- 1
  
  coef_i <- unique(clogit_coefs$coef)[i]

  coef <- c(coef, coef_i)
  
  mean <- c(mean, 
            mean(x = clogit_coefs[which(clogit_coefs$coef == coef_i),]$value))
  
  w_mean <- c(w_mean, 
            weighted.mean(x = clogit_coefs[which(clogit_coefs$coef == coef_i),]$value,
              w = clogit_coefs[which(clogit_coefs$coef == coef_i),]$weight))

}

clogit_weighted_means <- data.frame(coef, mean, w_mean)
clogit_weighted_means

```

Calculating the coefficient curves across the year (by yday)

```{r}

# clogit_coef_df <- clogit_model_coef_list[[1]]

x_yday <- seq(1, 365, 1)

y_yday <- function(x,
                    lin_coef,
                    sin_coef1,
                    sin_coef2,
                    cos_coef1,
                    cos_coef2) {

  lin_coef +
    (sin_coef1 * sin(2 * pi * x / 365)) +
    (sin_coef2 * sin(4 * pi * x / 365)) +
    (cos_coef1 * cos(2 * pi * x / 365)) +
    (cos_coef2 * cos(4 * pi * x / 365))
}



harmonic_coefs_function <- function(clogit_coef_df) {

y_ndvi <- map_dbl(x_yday,
             y_yday,
             clogit_coef_df$value[which(clogit_coef_df$coef == "ndvi_scaled")],
             clogit_coef_df$value[which(clogit_coef_df$coef == "ndvi_scaled:yday_s1")],
             clogit_coef_df$value[which(clogit_coef_df$coef == "ndvi_scaled:yday_s2")],
             clogit_coef_df$value[which(clogit_coef_df$coef == "ndvi_scaled:yday_c1")],
             clogit_coef_df$value[which(clogit_coef_df$coef == "ndvi_scaled:yday_c2")])

y_ndvi_quad <- map_dbl(x_yday,
             y_yday,
             clogit_coef_df$value[which(clogit_coef_df$coef == "I(ndvi_scaled^2)")],
             clogit_coef_df$value[which(clogit_coef_df$coef == "I(ndvi_scaled^2):yday_s1")],
             clogit_coef_df$value[which(clogit_coef_df$coef == "I(ndvi_scaled^2):yday_s2")],
             clogit_coef_df$value[which(clogit_coef_df$coef == "I(ndvi_scaled^2):yday_c1")],
             clogit_coef_df$value[which(clogit_coef_df$coef == "I(ndvi_scaled^2):yday_c2")])

# y_ndvi_yday <- map_dbl(x_yday,
#              y_yday,
#              clogit_coef_df$value[which(clogit_coef_df$coef == "ndvi_temporal")],
#              clogit_coef_df$value[which(clogit_coef_df$coef == "ndvi_temporal:yday_s1")],
#              clogit_coef_df$value[which(clogit_coef_df$coef == "ndvi_temporal:yday_s2")],
#              clogit_coef_df$value[which(clogit_coef_df$coef == "ndvi_temporal:yday_c1")],
#              clogit_coef_df$value[which(clogit_coef_df$coef == "ndvi_temporal:yday_c2")])

# y_wofs05_yday <- map_dbl(x_yday,
#              y_yday,
#              clogit_coef_df$value[which(clogit_coef_df$coef == "WOFS05_dist_scaled")],
#              clogit_coef_df$value[which(clogit_coef_df$coef == "WOFS05_dist_scaled:yday_s1")],
#              clogit_coef_df$value[which(clogit_coef_df$coef == "WOFS05_dist_scaled:yday_s2")],
#              clogit_coef_df$value[which(clogit_coef_df$coef == "WOFS05_dist_scaled:yday_c1")],
#              clogit_coef_df$value[which(clogit_coef_df$coef == "WOFS05_dist_scaled:yday_c2")])
# 
# y_wofs05_Q_yday <- map_dbl(x_yday,
#              y_yday,
#              clogit_coef_df$value[which(clogit_coef_df$coef == "I(WOFS05_dist_scaled^2)")],
#              clogit_coef_df$value[which(clogit_coef_df$coef == "I(WOFS05_dist_scaled^2):yday_s1")],
#              clogit_coef_df$value[which(clogit_coef_df$coef == "I(WOFS05_dist_scaled^2):yday_s2")],
#              clogit_coef_df$value[which(clogit_coef_df$coef == "I(WOFS05_dist_scaled^2):yday_c1")],
#              clogit_coef_df$value[which(clogit_coef_df$coef == "I(WOFS05_dist_scaled^2):yday_c2")])

# y_slope_yday <- map_dbl(x_yday,
#              y_yday,
#              clogit_coef_df$value[which(clogit_coef_df$coef == "slope_scaled")],
#              clogit_coef_df$value[which(clogit_coef_df$coef == "slope_scaled:yday_s1")],
#              clogit_coef_df$value[which(clogit_coef_df$coef == "slope_scaled:yday_s2")],
#              clogit_coef_df$value[which(clogit_coef_df$coef == "slope_scaled:yday_c1")],
#              clogit_coef_df$value[which(clogit_coef_df$coef == "slope_scaled:yday_c2")])

# y_herby_yday <- map_dbl(x_yday,
#              y_yday,
#              clogit_coef_df$value[which(clogit_coef_df$coef == "veg_herby")],
#              clogit_coef_df$value[which(clogit_coef_df$coef == "veg_herby:yday_s1")],
#              clogit_coef_df$value[which(clogit_coef_df$coef == "veg_herby:yday_s2")],
#              clogit_coef_df$value[which(clogit_coef_df$coef == "veg_herby:yday_c1")],
#              clogit_coef_df$value[which(clogit_coef_df$coef == "veg_herby:yday_c2")])

y_canopy <- map_dbl(x_yday,
             y_yday,
             clogit_coef_df$value[which(clogit_coef_df$coef == "canopy_scaled")],
             clogit_coef_df$value[which(clogit_coef_df$coef == "canopy_scaled:yday_s1")],
             clogit_coef_df$value[which(clogit_coef_df$coef == "canopy_scaled:yday_s2")],
             clogit_coef_df$value[which(clogit_coef_df$coef == "canopy_scaled:yday_c1")],
             clogit_coef_df$value[which(clogit_coef_df$coef == "canopy_scaled:yday_c2")])

y_canopy_quad <- map_dbl(x_yday,
             y_yday,
             clogit_coef_df$value[which(clogit_coef_df$coef == "I(canopy_scaled^2)")],
             clogit_coef_df$value[which(clogit_coef_df$coef == "I(canopy_scaled^2):yday_s1")],
             clogit_coef_df$value[which(clogit_coef_df$coef == "I(canopy_scaled^2):yday_s2")],
             clogit_coef_df$value[which(clogit_coef_df$coef == "I(canopy_scaled^2):yday_c1")],
             clogit_coef_df$value[which(clogit_coef_df$coef == "I(canopy_scaled^2):yday_c2")])

y_sl <- map_dbl(x_yday,
             y_yday,
             clogit_coef_df$value[which(clogit_coef_df$coef == "sl")],
             clogit_coef_df$value[which(clogit_coef_df$coef == "sl:yday_s1")],
             clogit_coef_df$value[which(clogit_coef_df$coef == "sl:yday_s2")],
             clogit_coef_df$value[which(clogit_coef_df$coef == "sl:yday_c1")],
             clogit_coef_df$value[which(clogit_coef_df$coef == "sl:yday_c2")])

y_log_sl <- map_dbl(x_yday,
             y_yday,
             clogit_coef_df$value[which(clogit_coef_df$coef == "log_sl")],
             clogit_coef_df$value[which(clogit_coef_df$coef == "log_sl:yday_s1")],
             clogit_coef_df$value[which(clogit_coef_df$coef == "log_sl:yday_s2")],
             clogit_coef_df$value[which(clogit_coef_df$coef == "log_sl:yday_c1")],
             clogit_coef_df$value[which(clogit_coef_df$coef == "log_sl:yday_c2")])

y_cos_ta <- map_dbl(x_yday,
             y_yday,
             clogit_coef_df$value[which(clogit_coef_df$coef == "cos_ta")],
             clogit_coef_df$value[which(clogit_coef_df$coef == "cos_ta:yday_s1")],
             clogit_coef_df$value[which(clogit_coef_df$coef == "cos_ta:yday_s2")],
             clogit_coef_df$value[which(clogit_coef_df$coef == "cos_ta:yday_c1")],
             clogit_coef_df$value[which(clogit_coef_df$coef == "cos_ta:yday_c2")])

return(data.frame("yday" = x_yday,
                  "NDVI" = y_ndvi, 
                  "NDVI_quadratic" = y_ndvi_quad, 
                  # "wofs05" = y_wofs05_yday, 
                  # "wofs05_Q" = y_wofs05_Q_yday, 
                  # "Slope" = y_slope_yday, 
                  # "Herbaceous_vegetation" = y_herby_yday, 
                  "Canopy_cover" = y_canopy, 
                  "Canopy_cover_quadratic" = y_canopy_quad, 
                  "Step_length" = y_sl,
                  "log_Step_length" = y_log_sl, 
                  "cos_Turning_angle" = y_cos_ta))

}

# testing to see if the function works
harmonic_coefs_function(clogit_model_coef_list[[1]])

# mapping over the function
harmonic_coefs_list <- map(clogit_model_coef_list, harmonic_coefs_function)
# unlisting
harmonic_coef_prebind <- do.call(rbind, harmonic_coefs_list)

# using the function on the weighted mean of the coefficients - creating a value column
clogit_weighted_means <- clogit_weighted_means %>% mutate(value = w_mean)
clogit_means <- clogit_weighted_means %>% mutate(value = mean)
# running the function
harmonic_weighted_mean <- harmonic_coefs_function(clogit_weighted_means)
harmonic_mean <- harmonic_coefs_function(clogit_means)

# binding the ID and weighted mean values
harmonic_coef_vals_w_mean <- rbind(harmonic_coef_prebind, harmonic_weighted_mean, harmonic_mean)

# combining
harmonic_coefs_df <- cbind("id" = rep(c(buffalo_ids, "Weighted mean", "Mean"), each = 365), harmonic_coef_vals_w_mean)

```


Reconstructing the Gamma and von Mises distributions from the tentative distributions (from Fieberg et al 2021: Appendix C)

```{r}

# for individuals
# movement_parameters <- read_csv("outputs/buffalo_parametric_indv_movement_params_20230208.csv")
# movement_parameters_year <- movement_parameters %>% filter(id %in% buffalo_year_ids)

# for the population
# gamma$params$shape # 0.438167
# gamma$params$scale # 534.3507
# vonmises$params$kappa # 0.1848126

tentative_shape <- 0.438167
tentative_scale <- 534.3507
tentative_kappa <- 0.1848126

harmonic_coefs_df <- harmonic_coefs_df %>% mutate(shape = tentative_shape + log_Step_length,
                             scale = 1/((1/tentative_scale) - Step_length),
                             kappa = tentative_kappa + cos_Turning_angle)

harmonic_weighted_mean <- harmonic_weighted_mean %>% mutate(shape = tentative_shape + log_Step_length,
                             scale = 1/((1/tentative_scale) - Step_length),
                             kappa = tentative_kappa + cos_Turning_angle)

# write_csv(harmonic_coefs_df, "outputs/harmonic_coefs_wide_with_movement_params_20230210.csv")

# turning into a long data frame
harmonic_coefs <- pivot_longer(harmonic_coefs_df, cols = !1:2, names_to = "coef")

# write_csv(harmonic_coefs, "outputs/harmonic_coefs_long_with_movement_params_20230209.csv")

```


```{r}

x <- seq(0,500,1)

# step length distribution
plot(x, dgamma(x, 
       shape = harmonic_coefs %>% filter(id == "Weighted mean" & month == 12) %>% 
         dplyr::filter(coef == "shape") %>% dplyr::pull(value),
       scale = harmonic_coefs %>% filter(id == "Weighted mean" & month == 12) %>% 
         dplyr::filter(coef == "scale") %>% dplyr::pull(value)),
     type = "l",
     main = "Step length distribution",
     xlab = "Distance (m)",
     ylab = "Density")

xvm <- seq(-pi, pi, 0.01)

plot(xvm, dvonmises(xvm, 
          mu = 0, 
          kappa = harmonic_coefs %>% filter(id == "Weighted mean" & month == 12) %>% 
            dplyr::filter(coef == "kappa") %>% dplyr::pull(value),
          log = FALSE),
     type = "l",
     main = "Turning angle distribution",
     xlab = "Turning angle (rad)",
     ylab = "Density",
     ylim = c(0,0.21))


```



```{r}

n <- 1e5

shape <- harmonic_coefs %>% filter(id == "Weighted mean" & month == 12) %>% dplyr::filter(coef == "shape") %>% dplyr::pull(value)
scale <- harmonic_coefs %>% filter(id == "Weighted mean" & month == 12) %>% dplyr::filter(coef == "scale") %>% dplyr::pull(value)
kappa <- harmonic_coefs %>% filter(id == "Weighted mean" & month == 12) %>% dplyr::filter(coef == "kappa") %>% dplyr::pull(value)

sl <- rgamma(n, shape = shape, scale = scale)
hist(sl, breaks = 100)
ta <- as.numeric(Rfast::rvonmises(n, m = pi, k = 0.78) - pi)
hist(ta, breaks = 100)

x_s <- sl * sin(ta)
y_s <- sl * cos(ta)
xy_mk <- data.frame("x_pos" = x_s, "y_pos" = y_s)

ggplot(data = xy_mk, aes(x = x_pos, y = y_pos)) +
  geom_point(alpha = 0.1) +
  # geom_density_2d_filled(data = xy_mk, aes(x = x_pos, y = y_pos)) +
  # geom_hex(bins = 30) +
  # geom_bin_2d(bins = 50) +
  scale_x_continuous("x position") +
  scale_y_continuous("y position") +
  # scale_fill_viridis_c() +
  geom_point(aes(x = 0, y = 0), colour = "red", alpha = 0.25) +
  coord_equal() +
  theme_bw()

```



```{r}

# write_csv(harmonics_coefs, "outputs/monthly_CLR_coefs_long_with_movement_params_20230228.csv")
# harmonics_coefs <- read_csv("outputs/monthly_CLR_coefs_long_with_movement_params_20230228.csv")

# ggplot() +
#   geom_point(data = harmonic_coefs, aes(x = month, y = value, colour = coef)) +
#   geom_hline(yintercept = 0, linetype = "dashed") +
#   theme_bw()
# 
# ggplot() +
#   geom_point(data = harmonic_coefs %>% filter(coef == "ndvi"), aes(x = month, y = value, colour = factor(id))) +
#   geom_hline(yintercept = 0, linetype = "dashed") +
#   theme_bw()
# 
# unique(harmonic_coefs$id)[1:10]

coefs <- unique(harmonic_coefs$coef)
# coef_titles <- c("NDVI", "Slope", "Herbaceous vegetation", "Canopy cover", "Step length", "log(Step length)", "cos(Turning angle)")

for(i in 1:length(coefs)) {
  
  gg <- ggplot() +
  geom_line(data = harmonic_coefs %>% 
              filter(id %in% unique(harmonic_coefs$id)[1:10]) %>% 
              filter(coef %in% unique(harmonic_coefs$coef)) %>% # [1:4]
              filter(coef == coefs[i]), 
            aes(x = yday, y = value, group = id), colour = "grey") + # , colour = factor(id)
    geom_line(data = harmonic_coefs %>% filter(id %in% unique(harmonic_coefs$id)[11:12]) %>% 
                filter(coef == coefs[i]), aes(x = yday, y = value, colour = factor(id))) +
    geom_hline(yintercept = 0, linetype = "dashed") +
    scale_y_continuous(expression(Time-varying~parameter~values~beta)) +
    scale_x_continuous() + # breaks = seq(0,)
    scale_color_discrete("Estimate") +
    ggtitle(coefs[i]) +
    theme_classic() +
    theme(legend.position = "bottom")
  
  print(gg)

  # ggsave(paste("outputs/plots/clr_fitting/clr_harmonic_20230208_", coef_titles[i], ".png", sep = ""),
  # width=150, height=90, units="mm", dpi = 300)
  
}


# with just the means 

ggplot() +
    geom_path(data = harmonic_coefs %>% 
                filter(id %in% unique(harmonic_coefs$id)[11]) %>% 
                filter(coef %in% unique(harmonic_coefs$coef)[1:7]), 
              aes(x = month, y = value, colour = coef)) +
    geom_hline(yintercept = 0, linetype = "dashed") +
    scale_y_continuous(expression(Time-varying~parameter~values~beta)) +
    scale_x_continuous("Month", breaks = 0:12) +
    scale_color_discrete("Estimate") +
    # ggtitle(coef_titles[i]) +
    theme_classic() +
    theme(legend.position = "bottom")

ggsave(paste("outputs/plots/clr_fitting/clr_harmonic_all_20230208.png", sep = ""),
  width=150, height=90, units="mm", dpi = 300)
ggsave(paste("outputs/plots/clr_fitting/clr_harmonic_all_pres_20230208.png", sep = ""),
  width=300, height=180, units="mm", dpi = 300)


ggplot() +
    geom_path(data = harmonic_coefs %>% 
                filter(id %in% unique(harmonic_coefs$id)[11]) %>% 
                filter(coef %in% unique(harmonic_coefs$coef)[8:10]), 
              aes(x = month, y = value, colour = coef)) +
    geom_hline(yintercept = 0, linetype = "dashed") +
    scale_y_continuous(expression(beta)) +
    scale_x_continuous(breaks = 0:12) +
    scale_color_discrete("Estimate") +
    # ggtitle(coef_titles[i]) +
    theme_classic() +
    theme(legend.position = "bottom")


ggplot() +
    geom_path(data = harmonic_coefs %>% 
                filter(id %in% unique(harmonic_coefs$id)[11]) %>% 
                filter(coef %in% unique(harmonic_coefs$coef)[c(8,10)]), 
              aes(x = month, y = value, colour = coef)) +
    geom_hline(yintercept = 0, linetype = "dashed") +
    scale_y_continuous(expression(beta)) +
    scale_x_continuous(breaks = 0:12) +
    scale_color_discrete("Estimate") +
    # ggtitle(coef_titles[i]) +
    theme_classic() +
    theme(legend.position = "bottom")

harmonic_coefs %>% filter(id %in% unique(harmonic_coefs$id)[11])

```




```{r}

x <- seq(0, 1000, length = 500)
dgamma(x, shape = tentative_shape, scale = tentative_scale)

temporal_movement_params <- harmonic_coefs_df %>% filter(id == "Weighted mean") %>% dplyr::select(c("month", "shape", "scale", "kappa"))
# write_csv(temporal_movement_params, "outputs/temporal_movement_params_CLR_20230210.csv")

ggplot() +
  stat_function(fun = dgamma, args = list(shape = tentative_shape, scale = tentative_scale)) +
  scale_x_continuous(limits = c(0,1000), breaks = seq(0,1000,100)) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  theme_classic()


subset <- temporal_movement_params %>% filter(month < 1)

ggplot(subset) +
  stat_function(fun = dgamma, args = list(shape = shape, scale = scale)) +
  scale_x_continuous(limits = c(0,1000), breaks = seq(0,1000,100)) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  theme_classic()

```


# Generating predictions

Importing habitat layers

```{r}

ndvi_projected <- rast("mapping/cropped rasters/ndvi_GEE_projected_watermask20230207.tif")

# scaling from the buffalo data
scaling_mean <- as.numeric(attributes(buffalo_CLR_year$ndvi_scaled)[1]) # 0.3125089
scaling_sd <- as.numeric(attributes(buffalo_CLR_year$ndvi_scaled)[2]) # 0.143179 for July 2018

ndvi_stack_scaled <- (ndvi_projected - scaling_mean) / scaling_sd
# plot(ndvi_stack_scaled)
time_vector <- terra::time(ndvi_projected)
terra::time(ndvi_stack_scaled) <- NULL
terra::time(ndvi_stack_scaled) <- lubridate::date(as.POSIXlt(as.POSIXlt("1970/01/01 00:00:00") + time_vector))


# plot(ndvi_projected[ndvi_projected > 0])
# 
# for(i in 1:nlyr(ndvi_projected)) {
#   ndvi_projected[[i]] <- ndvi_projected[[i]]
# }
# 
# hist(buffalo_CLR$ndvi_temporal, breaks = 100)
# 
# # terra::set.values(ndvi_projected, < 0, NA)
# ndvi_above_0 <- ifel(ndvi_projected < 0, NA, ndvi_projected)
# plot(ndvi_above_0)
# 
# # scaling ndvi by a single month
# 
# plot(ndvi_projected[[16]])
# plot(ndvi_projected[[16]] < 0)
# 
# # ndvi_july2018_scaled <- scale(ndvi_projected[[7]])
# # plot(ndvi_july2018_scaled)
# # 
# # scaling_mean <- mean(values(ndvi_projected[[7]], na.rm = TRUE)) # 0.4054526 for July 2018
# # scaling_sd <- sd(values(ndvi_projected[[7]], na.rm = TRUE)) # 0.1113644 for July 2018
# # 
# # ndvi_stack_scaled <- (ndvi_projected - mean(values(ndvi_projected[[7]], na.rm = TRUE))) / sd(values(ndvi_projected[[7]], na.rm = TRUE))
# # plot(ndvi_stack_scaled)
# ndvi_stack_scaled <- (ndvi_above_0 - mean(values(ndvi_projected[[7]], na.rm = TRUE))) / sd(values(ndvi_projected[[7]], na.rm = TRUE))
# plot(ndvi_stack_scaled)

# ndvi_above0_stack_scaled <- ndvi_stack_scaled
# terra::writeRaster(ndvi_above0_stack_scaled, "mapping/cropped rasters/ndvi_above0_stack_scaled_20230210.tif")
ndvi_above0_stack_scaled <- rast("mapping/cropped rasters/ndvi_above0_stack_scaled_20230210.tif")


```



```{r}

# elev <- raster("mapping/cropped rasters/DEM_H_raster.tif")
# slope <- raster("mapping/cropped rasters/slope_raster.tif")
# veg_herby <- raster("mapping/cropped rasters/veg_herby.tif")
# canopy_cover <- raster("mapping/cropped rasters/canopy_cover.tif")
# 
# names(elev) <- "elev"
# names(slope) <- "slope"
# names(veg_herby) <- "veg_herby"
# names(canopy_cover) <- "canopy_cover"

```

For plotting with terra 

```{r}

# elev <- rast("mapping/cropped rasters/DEM_H_raster.tif")
slope <- rast("mapping/cropped rasters/slope_raster.tif")
veg_herby <- rast("mapping/cropped rasters/veg_herby.tif")
canopy_cover <- rast("mapping/cropped rasters/canopy_cover.tif")
# 
# ndvi_july2018 <- ndvi_projected[[7]]
# 
# names(slope) <- "Slope"
# names(veg_herby) <- "Herbaceous vegetation"
# names(canopy_cover) <- "Canopy cover"
# names(ndvi_july2018) <- "NDVI July 2018"
# 
# # plot(elev)
# plot(slope)
# plot(veg_herby)
# plot(canopy_cover)
# plot(ndvi_july2018)
# 
# plot_stack <- c(ndvi_july2018, slope, veg_herby, canopy_cover)
# 
# png(filename = "outputs/plots/ndvi_slope_herb_canopy_layers_20230208.png",
#     width = 300, height = 175, units = "mm", res = 300)
# plot(plot_stack)
# dev.off()

```

Scaled rasters

```{r}

# hist(buffalo_CLR_year$slope_scaled)
# slope_scaled <- (slope - attr(buffalo_CLR_year$slope_scaled, "scaled:center")) / attr(buffalo_CLR_year$slope_scaled, "scaled:scale")
# plot(slope_scaled)
# 
# writeRaster(slope_scaled, "mapping/cropped rasters/slope_scaled_by_buffalo_data_20230210.tif")
slope_scaled <- rast("mapping/cropped rasters/slope_scaled_by_buffalo_data_20230210.tif")

# hist(buffalo_CLR_year$canopy_scaled)
# canopy_scaled <- ((canopy_cover / 100) - attr(buffalo_CLR_year$canopy_scaled, "scaled:center")) / attr(buffalo_CLR_year$canopy_scaled, "scaled:scale")
# plot(canopy_scaled)
# 
# writeRaster(canopy_scaled, "mapping/cropped rasters/canopy_scaled_by_buffalo_data_20230210.tif")
canopy_scaled <- rast("mapping/cropped rasters/canopy_scaled_by_buffalo_data_20230210.tif")

```


Checking distributions of covariates vs used and random locations

```{r}

ndvi_values_month1 <- values(ndvi_above0_stack_scaled[[13]])
canopy_values <- values(canopy_cover)
# slope_values <- values(slope_scaled)
# herby_values <- values(veg_herby)

enviro_values <- data.frame("Data" = rep("Environmental", length(values(canopy_cover))), "pres" = rep(1, length(values(canopy_cover))),  "ndvi" = ndvi_values_month1, "canopy" = canopy_values, "slope" = slope_values, "herby" = herby_values)
names(enviro_values) <- c("Data", "pres", "ndvi", "canopy", "slope", "herby")

buffalo_pres_values <- buffalo_CLR_year %>% filter(y == 1 & year == 2019 & month == 3) %>%  transmute(Data = "Presence", pres = y, ndvi = ndvi_temporal, canopy = canopy_cover, slope = slope_end, herby = veg_herby)

buffalo_background_values <- buffalo_CLR_year %>% filter(y == 0 & year == 2019 & month == 3) %>%  transmute(Data = "Random steps", pres = y, ndvi = ndvi_temporal, canopy = canopy_cover, slope = slope_end, herby = veg_herby)

enviro_buffalo_values <- rbind(enviro_values, buffalo_pres_values, buffalo_background_values)

# ggplot(enviro_buffalo_values) +
#   geom_density(aes(x = ndvi, fill = method), alpha = 0.5) +
#   geom_density(data = buffalo_CLR_year %>% filter(y == 1, year == 2019 & month == 1), 
#                aes(x = ndvi_temporal), fill = "orange", alpha = 0.5) +
#   geom_density(data = buffalo_CLR_year %>% filter(y == 0, year == 2019 & month == 1), 
#                aes(x = ndvi_temporal), linetype = "dashed", colour = "red", alpha = 0.5) +
#   theme_classic()

ggplot() +
  geom_density(data = enviro_buffalo_values, aes(x = ndvi, fill = Data), alpha = 0.25) +
  theme_classic()

ggplot() +
  geom_density(data = enviro_buffalo_values, aes(x = slope, fill = Data), alpha = 0.25) +
  theme_classic()


tab <- as.data.frame(prop.table(table(enviro_buffalo_values$canopy, enviro_buffalo_values$Data), 2))
names(tab) <- c("Canopy_cover", "Data", "Freq")

ggplot(data = tab, aes(x = Canopy_cover, y = Freq, fill = Data)) +
  geom_bar(stat = "identity", position = position_dodge(), alpha = 0.75) +
  theme_classic()

```




```{r temporal naive}

years <- c(rep(2019, 7), rep(2018, 5))
months <- c(seq(1, 7, 1), seq(8, 12, 1))
day <- rep(1, 12)
dates <- make_datetime(year = years, month = months, day = day, tz = "Australia/Queensland")

# temp_coefs <- data.frame("date" = dates, 
#                          "ndvi" = harmonic_weighted_mean$NDVI[seq(1, 111, 10)], 
#                          "slope" = harmonic_weighted_mean$Slope[seq(1, 111, 10)], 
#                          "veg_herby" = harmonic_weighted_mean$Herbaceous_vegetation[seq(1, 111, 10)], 
#                          "canopy" = harmonic_weighted_mean$Canopy_cover[seq(1, 111, 10)])

monthly_coefs <- data.frame("date" = dates,
                         "ndvi" = harmonic_weighted_mean$NDVI[seq(1, 331, 30)],
                         "ndvi_quad" = harmonic_weighted_mean$NDVI_quadratic[seq(1, 331, 30)],
                         # "slope" = harmonic_weighted_mean$Slope[seq(1, 331, 30)],
                         # "veg_herby" = harmonic_weighted_mean$Herbaceous_vegetation[seq(1, 331, 30)],
                         "canopy" = harmonic_weighted_mean$Canopy_cover[seq(1, 331, 30)],
                         "canopy_quad" = harmonic_weighted_mean$Canopy_cover_quadratic[seq(1, 331, 30)],
                         "shape" = harmonic_weighted_mean$shape[seq(1, 331, 30)],
                         "scale" = harmonic_weighted_mean$scale[seq(1, 331, 30)],
                         "kappa" = harmonic_weighted_mean$kappa[seq(1, 331, 30)])

# write_csv(monthly_coefs, "outputs/weighted_mean_monthly_CLR_coefs_wide_yday_with_movement_params_20230424.csv") # weighted mean

monthly_coefs_long <- monthly_coefs %>% pivot_longer(cols = !date)

# sanity check to ensure that the coefficients line up to the correct months
monthly_coefs_long %>% filter(!name %in% c("shape", "scale", "kappa")) %>% ggplot(aes(x = month(date), y = value, colour = factor(name))) +
  geom_line() +
  scale_colour_viridis_d("Covariate") +
  geom_hline(yintercept = 0, linetype = "dashed") +
  scale_x_continuous(breaks = 1:12) +
  theme_classic()

```



```{r}

# resources <- raster::stack(ndvi_raster_amt[[which(getZ(ndvi_raster_amt) == "2019-02-15")]], 
#                            ndwi_raster_amt[[which(getZ(ndwi_raster_amt) == "2019-02-15")]], 
#                            veg_herby, 
#                            canopy_01) #, veg_woody, WOFS80_dist, slope
# 
# extent(resources) <- c(0, 60000, 0, 57000)
# 
# plot(resources)
# 
# emp_coefs <- clogit_model$model$coefficients[1:4]

```


# Predictions and cross-validation

Boyce index function

```{r}

ecospat.boyce2 <- function (fit, obs, nclass = 0, window.w = "default", res = 100, 
  PEplot = TRUE, rm.duplicate = TRUE, method = "spearman") 
{
  boycei <- function(interval, obs, fit) {
    pi <- sum(as.numeric(obs >= interval[1] & obs <= interval[2]))/length(obs)
    ei <- sum(as.numeric(fit >= interval[1] & fit <= interval[2]))/length(fit)
    return(round(pi/ei, 10))
  }
  if (inherits(fit, "RasterLayer")) {
    if (is.data.frame(obs) || is.matrix(obs)) {
      obs <- raster::extract(fit, obs)
    }
    fit <- getValues(fit)
    fit <- fit[!is.na(fit)]
    obs <- obs[!is.na(obs)]
  }
  mini <- min(fit, obs)
  maxi <- max(fit, obs)
  if (length(nclass) == 1) {
    if (nclass == 0) {
      if (window.w == "default") {
        window.w <- (max(fit) - min(fit))/10
      }
      vec.mov <- seq(from = mini, to = maxi - window.w, 
        by = (maxi - mini - window.w)/res)
      vec.mov[res + 1] <- vec.mov[res + 1] + 1
      interval <- cbind(vec.mov, vec.mov + window.w)
    }
    else {
      vec.mov <- seq(from = mini, to = maxi, by = (maxi - 
        mini)/nclass)
      interval <- cbind(vec.mov, c(vec.mov[-1], maxi))
    }
  }
  else {
    vec.mov <- c(mini, sort(nclass[!nclass > maxi | nclass < 
      mini]))
    interval <- cbind(vec.mov, c(vec.mov[-1], maxi))
  }
  f <- apply(interval, 1, boycei, obs, fit)
  to.keep <- which(f != "NaN")
  f <- f[to.keep]
  if (length(f) < 2) {
    b <- NA
  }
  else {
    r <- 1:length(f)
    if (rm.duplicate == TRUE) {
      r <- c(1:length(f))[f != c(f[-1], TRUE)]
    }
    b <- cor(f[r], vec.mov[to.keep][r], method = method)
  }
  HS <- apply(interval, 1, sum)/2
  if (length(nclass) == 1 & nclass == 0) {
    HS[length(HS)] <- HS[length(HS)] - 1
  }
  HS <- HS[to.keep]
  if (PEplot == TRUE) {
    plot(HS, f, xlab = "Habitat suitability", ylab = "Predicted/Expected ratio", 
      col = "grey", cex = 0.75)
    points(HS[r], f[r], pch = 19, cex = 0.75)
  }
  return(list(F.ratio = f, cor = round(b, 3), HS = HS))
}

```




```{r}

boyce_naive_list <- vector(mode = "list", length = 12)
naive_pred_stack <- c()

for(i in 1:12) {

resources <- c(ndvi_stack_scaled[[which(time(ndvi_stack_scaled) == monthly_coefs$date[i])]], 
               # slope_scaled,
               # veg_herby, 
               canopy_scaled)

# ndvi
ndvi_lin <- resources[[1]]
ndvi_lin <- ndvi_lin * monthly_coefs$ndvi[[i]]
# plot(ndvi_lin)

ndvi_quad <- resources[[1]]
ndvi_quad <- (ndvi_quad ^ 2) * monthly_coefs$ndvi_quad[[i]] 
# plot(ndvi_quad)

ndvi_pred <- ndvi_lin + ndvi_quad
# plot(ndvi_pred)

# canopy cover 
canopy_lin <- resources[[2]]
canopy_lin <- canopy_lin * monthly_coefs$canopy[[i]]
# plot(canopy_lin)

canopy_quad <- resources[[2]]
canopy_quad <- (canopy_quad ^ 2) * monthly_coefs$canopy_quad[[i]] 
# plot(canopy_quad)

canopy_pred <- canopy_lin + canopy_quad
# plot(canopy_pred)

# combining
naive_pred <- exp(ndvi_pred + canopy_pred) / global(exp(ndvi_pred + canopy_pred), fun = "sum", na.rm = TRUE)[[1]]
plot(naive_pred)
plot(naive_pred)
points(as.numeric(buffalo_CLR_year %>% filter(y == 1 & month == i) %>% dplyr::select(x1) %>% unlist()), 
       as.numeric(buffalo_CLR_year %>% filter(y == 1 & month == i) %>% dplyr::select(y1) %>% unlist()))

naive_pred_stack <- c(naive_pred_stack, naive_pred)


# setting up the buffalo observation data for the relevant month

# buffalo_obs <- buffalo_CLR_year %>% 
#   filter(y == 1 & month == 1 & x1 > xmin & x1 < xmax & y1 > ymin & y1 < ymax) %>% 
#   transmute(x = x1 - xmin, y = y1 - ymin)

buffalo_obs <- buffalo_CLR_year %>% filter(y == 1 & month == i) %>% 
  transmute(x = x1, y = y1)

naive_raster <- raster(naive_pred)
# naive_raster <- raster(naive_pred_cropped)

# plot(naive_pred)
# plot(naive_raster)

# plot(naive_cropped_raster[[1]])

# boyce_naive <- ecospat.boyce2(naive_cropped_raster[[1]], buffalo_obs,
#                               # method = "spearman"
#                               method = "pearson",
#                               # method = "kendall"
#                               )

boyce_naive_list[[i]] <- ecospat.boyce2(naive_raster, buffalo_obs,
                              method = "spearman"
                              # method = "pearson",
                              # method = "kendall"
                              )

boyce_naive_list[[i]]

}

```


```{r}

for(i in 1:12) {
  plot(naive_pred_stack[[i]])
}

for(i in 1:12) {
  # plot(naive_pred_stack[[i]])
  plot(naive_pred_stack[[i]])
  points(as.numeric(buffalo_CLR_year %>% filter(y == 1 & month == i) %>% dplyr::select(x1) %>% unlist()), 
       as.numeric(buffalo_CLR_year %>% filter(y == 1 & month == i) %>% dplyr::select(y1) %>% unlist()))
}

```


```{r}

for(i in 1:12) print(boyce_naive_list[[i]]$cor)

```
















```{r temporal naive}

layers_naive <- c()

for(i in 1:12) {

resources <- c(ndvi_stack_scaled[[which(time(ndvi_stack_scaled) == temp_coefs$date[i])]], 
               slope_scaled,
               veg_herby, 
               canopy_scaled)

# plot(resources)
# extent(resources) <- c(0, 60000, 0, 57000)

naive <- rast(resources)[[1]]
naive <- terra::setValues(naive, 0)
names(naive) <- "naive_predictions"
  
for (j in 1:4) {
  naive <- naive + temp_coefs[i,][[j + 1]] * resources[[j]]
}
  
naive_norm <- exp(naive)/global(exp(naive), fun = "sum", na.rm = TRUE)[[1]]
terra::plot(naive_norm)
layers_naive <- c(layers_naive, naive_norm)

}

naive_predictions <- rast(layers_naive)
plot(naive_predictions)

# layers <- mask(layers, water, maskvalue = 1)
# raster::plot(layers, col = brewer.pal(9, "Reds"), main = dates)

time(naive_predictions) <- dates
time(naive_predictions) 

for(i in 1:12) (plot(naive_predictions[[i]], main = time(naive_predictions[[i]])))

```


Changing to a 0 to 1 scale. 

```{r}

naive_predictions_01_list <- c()

for(i in 1:12) {
  naive_predictions_01[[i]] <- (naive_predictions[[i]] - global(naive_predictions[[i]], fun = "min", na.rm = TRUE)[[1]]) / 
    (global(naive_predictions[[i]], fun = "max", na.rm = TRUE)[[1]] - global(naive_predictions[[i]], fun = "min", na.rm = TRUE)[[1]]) }

naive_predictions_01 <- rast(naive_predictions_01_list)
plot(naive_predictions_01)

for(i in 1:12) (plot(naive_predictions_01[[i]], main = time(naive_predictions_01[[i]])))

```


Naive predictions in ggplot

```{r}

naive_layer_dfs <- vector(mode = "list", length = nlyr(naive_predictions))

for(i in 1:nlyr(naive_predictions)) {
  naive_layer_dfs[[i]] <- as.data.frame(naive_predictions[[i]], xy = TRUE)
}

# to set fill limits so they're all on the same probability scale

mins <- numeric()
maxs <- numeric()
for(i in 1:12) mins[i] <- min(naive_layer_dfs[[i]]$naive_predictions, na.rm = TRUE)
for(i in 1:12) maxs[i] <- max(naive_layer_dfs[[i]]$naive_predictions, na.rm = TRUE)
min(mins)
max(maxs)

buffalo_year <- buffalo_CLR_year %>% filter(t1 > as.POSIXct("2018-08-01 00:00:00", tz = "UTC")) %>% 
  filter(t1 < as.POSIXct("2019-08-01 00:00:00", tz = "UTC"))

months <- month(time(naive_predictions)) # as 1:12 probably don't need to use the subset

for(i in 1:12) {
  
  # i = 1

ggplot() +
  geom_raster(data = naive_layer_dfs[[i]], 
              aes(x = x, y = y, fill = naive_layer_dfs[[i]][,3])) + # naive_norm_df[,i + 2]
  scale_fill_viridis_c("Habitat suitability", direction = 1, 
                       option = "D", limits = c(0.000000008812208, 0.0000004827002)) +
    geom_point(data = buffalo_year %>% filter(month == i & y == 1), 
               aes(x = x1, y = y1), size = 0.1, colour = "red", alpha = 0.25) +
  # scale_fill_gradient(low = "white", high = "purple") +
  # scale_fill_distiller("Habitat suitability", palette = "RdYlBu") +
  # ggthemes::scale_fill_te
  coord_equal() +
  # facet_wrap(facets = vars(month)) +
  # transition_states(month, transition_length = 3, state_length = 1)
  ggtitle(paste("Naive approach", time(naive_predictions_01[[i]]), sep = " ")) +
  theme_bw() +
  theme(legend.position = "right", legend.key.width = unit(1, "cm"))

ggsave(filename = paste("outputs/plots/naive_monthly_wpoints_", time(naive_predictions[[i]]), "_20230209.png", sep = ""), width=180, height=100, units="mm", dpi = 300)

}

colnames(naive_layer_dfs[[1]])[3]

```


```{r}

naive_comparison <- naive_predictions[[1]]
ext(naive_comparison) <- c(0, 60000, 0, 57000)
terra::plot(naive_comparison)
naive_comparison_cropped <- terra::crop(naive_comparison, ext(25000, 35500, 25000, 35500))
# ext(resources_cropped) <- c(ext(resources_cropped)[1] - ext(resources_cropped)[1], 
#                             ext(resources_cropped)[2] - ext(resources_cropped)[1], 
#                             ext(resources_cropped)[3] - ext(resources_cropped)[3], 
#                             ext(resources_cropped)[4] - ext(resources_cropped)[3])

terra::plot(naive_comparison_cropped)

min(naive_layer_dfs[[i]]$y, na.rm = TRUE)

naive_comparison_cropped_df <- as.data.frame(naive_comparison_cropped, xy = TRUE)

ggplot() +
  geom_raster(data = naive_comparison_cropped_df, 
              aes(x = x, y = y, fill = naive_comparison_cropped_df[,3])) + # naive_norm_df[,i + 2]
  scale_fill_viridis_c("Habitat suitability", direction = 1, 
                       option = "D") + # , limits = c(0.000000008812208, 0.0000004827002)
    geom_point(data = buffalo_year %>% filter(month == 1 &y == 1), 
               aes(x = x1, y = y1 + 1462963, colour = factor(id)), size = 0.5, alpha = 0.75) + # colour = "red", 
  coord_equal() +
  scale_x_continuous(limits = c(30000, 35000)) +
  scale_y_continuous(limits = c(25000, 30000)) +
  # ggtitle(paste("Naive approach", time(naive_predictions_01[[i]]), sep = " ")) +
  theme_bw() +
  theme(legend.position = "right", legend.key.width = unit(1, "cm"))

```



```{r}

# install.packages("Rfast")
library(Rfast)

# empirical_steps <- buffalo_all_covs %>% filter(y == 1) %>% .$sl_ 
# empirical_angles <- buffalo_all_covs %>% filter(y == 1) %>% .$ta_
# empirical_pairs <- bind_cols("steps" = empirical_steps, "angles" = empirical_angles) %>% drop_na()

temporal_movement_params$shape[1]

# slice_sample(empirical_pairs, n = 5, replace = T)

n_steps <- 10
n_ch <- 100
coef <- cov_values
xy0 <- start_unif
resc <- resources

simulate_ssf <- function(n_steps, n_ch, coef, xy0, resc) { 
  #sl <- rexp(n_steps * n_ch, rate = l) # l = 1, add into arguments if using exponential distribution for sl
  sl <- rgamma(n_steps * n_ch, shape = temporal_movement_params$shape[1], scale = temporal_movement_params$scale[1])
  ta <- rvonmises(n_steps * n_ch, m = 0, k = temporal_movement_params$kappa[1]) - pi
  # hist(ta)
  #ta <- runif(n_steps * n_ch, -pi, pi)
  # sl <- unlist(as.vector(slice_sample(empirical_pairs, n = n_steps * n_ch, replace = T)[,1]))
  # ta <- unlist(as.vector(slice_sample(empirical_pairs, n = n_steps * n_ch, replace = T)[,2]))
  #stp_ta <- slice_sample(empirical_pairs, n = n_steps * n_ch, replace = T)
  #sl <- as.vector(stp_ta[,1])
  #ta <- as.numeric(stp_ta[,2])
  #sl <- base::sample(x = empirical_steps, size = n_steps * n_ch, replace = TRUE)
  #ta <- base::sample(x = empirical_angles, size = n_steps * n_ch, replace = TRUE)
  steps <- rep(1:n_steps, each = n_ch)
  x_0 <- xy0[1]
  y_0 <- xy0[2]
  x_s <- sl * sin(ta)
  y_s <- sl * cos(ta)
  x <- rep(NA, n_steps)
  y <- rep(NA, n_steps)
  x[1] <- x_0
  y[1] <- y_0
  # multiply resources with selection coef
  for (i in 1:length(coef)) resc[[i]] <- resc[[i]] * coef[i][[1]]
  
  # i = 2
  
  for (i in 2:n_steps) {
    x_pos <- (x[i - 1] + sl[steps == i] * sin(ta[steps == i])) %% ext(resc)[2] # adding the modulo operator %% ensures a wrapped/toroid landscape, but the origin must be at (0,0)
    y_pos <- (y[i - 1] + sl[steps == i] * cos(ta[steps == i])) %% ext(resc)[4]
    p <- exp(rowSums(terra::extract(resc, cbind(x_pos, y_pos))))
    p[is.na(p)] <- 1e-6
    w <- sample(n_ch, 1, prob = p)
    x[i] <- x_pos[w]
    y[i] <- y_pos[w]
  }
  data_frame(x = x, y = y)
}

```


Setting up before the simulation
- resource layers
- coefficient values
- random starting locations

```{r}

resources <- c(ndvi_stack_scaled[[which(time(ndvi_stack_scaled) == temp_coefs$date[1])]], 
               slope_scaled,
               veg_herby, 
               canopy_scaled)

ext(resources) <- c(0, 60000, 0, 57000)
plot(resources)

coef_values <- harmonic_weighted_mean[1,][1:4]

start_unif <- cbind(runif(1000, min = ext(resources)[1], max = ext(resources)[2]), runif(100, min = ext(resources)[3], max = ext(resources)[4]))

```



```{r}

#simulate_ssf <- function(n_steps, n_ch, l = 1, coef, xy0, resc) {

tic()
stps <- map(1:10, function(i) 
  simulate_ssf(n_steps = 1e3, n_ch = 50, coef = coef_values, xy0 = start_unif[i,], resc = resources)
  )
toc()

# 50 individuals, n_steps = 1e4, n_ch = 50 - 3364.03 sec elapsed
 
# simulate_ssf(1000, 1, 1, omgs[i, ], start_unif[i,], resc)
  
  # stps <- map(1:50, function(i) 
  #   #    simulate_ssf(round(runif(1, 25, 200)), 200, 2, 1, omgs[i, ], c(200, 200), resc)
  #   #simulate_ssf <- function(n_steps, n_ch, l = 1, coef, xy0, resc)
  #   #simulate_ssf(1000, 100, 1, omgs[i, ], start_omgs[i,], resc)
  #   simulate_ssf(1000, 10, 1, omgs[i, ], start_unif[i,], resc)
  # )

animals <- data_frame(
  id = paste0("a", 1:10),
  track = map(stps, ~ track(x = .$x, y = .$y, t = ymd_hm("2019-01-01 00:00") + hours(1:nrow(.))))
)


sim_data <- unnest(animals, cols = track)

#sim_data <- data.frame(x = stps$x, y = stps$y, t = ymd_hm("2022-01-01 00:00") + hours(1:nrow(stps)))
# sim_data1 %>% transmute(id = "a0", x_ = x, y_ = y, t_ = t)
# 
# sim_all <- bind_rows(sim_data1 %>% transmute(id = "a0", x_ = x, y_ = y, t_ = t), sim_data)
# sim_data <- sim_all
#sim_20_inds_1000_50 <- sim_data


# write_csv(sim_data, "outputs/buffalo_w_mean_bcrw_10indvs_1e3stps_20230210.csv")

```




```{r}

plot(resources[[1]])
points(x = sim_data$x_, y = sim_data$y_)


ndvi_df <- as.data.frame(resources[[1]], xy = TRUE)

#bcrw <- 
ggplot() +
  geom_raster(data = ndvi_df, aes(x = x, y = y, fill = ndvi)) +
  #geom_path(data = sim_data, aes(x = x_, y = y_, colour = id), size = 1) +
  geom_point(data = sim_data, aes(x = x_, y = y_), size = 0.1, colour = "black", alpha = 0.1) +
  geom_point(data = buffalo_subset %>% filter(y == 1), aes(x = x1_, y = y1_ + 1463000), size = 0.1, colour = "red") +
  scale_fill_viridis_c() +
  #scale_fill_gradient(low = "white", high = "darkgreen") +
  coord_equal() +
  ggtitle("Simulation Approach") +
  theme_bw() +
  theme(legend.position = "bottom", legend.key.width = unit(1.1, "cm"))

bcrw


# buffalo_subset %>% filter(y == 1)

```


## generating distribution map

```{r}

points <- resources[[1]]
points[] <- 0

sim_ud_points <- as.matrix(sim_data[,2:3])

counts <- table(raster::cellFromXY(resources[[1]], sim_ud_points))

points[as.numeric(names(counts))] <- counts

plot(points)
# plot(points)
# points(x = sim_data$x, y = sim_data$y)  

points_ud <- points / cellStats(points, stat = "sum")
cellStats(points_ud, stat = "sum")
points_df <- as.data.frame(points_ud, xy = TRUE)
points_df$layer <- points_df$ndvi

bcrw <- 
  ggplot() +
  geom_raster(data = points_df, aes(x = x, y = y, fill = layer)) +
  #geom_point(data = animals_ssf %>% filter(case_ == TRUE), aes(x = x1_, y = y1_, colour = id), size = 0.5) +
  #scale_fill_viridis_c() +
  scale_fill_gradient(low = "white", high = "red") +
  coord_equal() +
  ggtitle("Simulation Approach") +
  theme_bw() +
  theme(legend.position = "bottom", legend.key.width = unit(1.1, "cm"))

bcrw

```



























```{r}

layers_df <- as.data.frame(layers, xy = TRUE)
colnames(layers_df) <- c("x", "y", as.character(as_date(dates)))
naive_temporal_df <- pivot_longer(layers_df, cols = 3:14, names_to = "date")

naive_temporal_list <- split(x = naive_temporal_df, f = naive_temporal_df$date)

```



```{r}

naive_temporal_ggplots <- vector(mode = "list", length = 12)

for(i in 1:12) {
  
naive_temporal_ggplots[[i]] <- ggplot() +
  geom_raster(data = naive_temporal_list[[i]], aes(x = x, y = y, fill = value)) +
  #scale_fill_viridis_c(direction = 1, option = "C") +
  scale_fill_gradient(low = "white", high = "red") +
  geom_point(data = buffalo_subset[which(buffalo_subset$month == month(dates[i])),] %>% 
               filter(y == 1), aes(x = x1_, y = y1_), size = 0.2, alpha = 0.5) +
  coord_equal() +
  ggtitle(paste("Naive Approach ", naive_temporal_list[[i]]$date, sep = "")) +
  theme_bw() +
  theme(legend.position = "bottom", legend.key.width = unit(1.1, "cm"))

}


for(i in 1:12) print(naive_temporal_ggplots[[i]])

assign(paste("preds_id", unique(buffalo_subset$id), sep = "_"), naive_temporal_ggplots)

```



```{r}

extent_subset <- raster(xmn = min(buffalo_subset$x2_), 
                        xmx = max(buffalo_subset$x2_), 
                        ymn = min(buffalo_subset$y2_), 
                        ymx = max(buffalo_subset$y2_), 
		crs = 3112, vals = 0)

# plot(extent_subset)

layers_subset <- raster::crop(x = layers, y = extent_subset)
# plot(layers_subset)

layers_subset_df <- as.data.frame(layers_subset, xy = TRUE)
colnames(layers_subset_df) <- c("x", "y", as.character(as_date(dates)))
naive_subset_temporal_df <- pivot_longer(layers_subset_df, cols = 3:14, names_to = "date") # %>% dplyr::arrange(date)

naive_subset_temporal_list <- split(x = naive_subset_temporal_df, f = naive_subset_temporal_df$date)

```



```{r plotting naive with subset extent}

naive_subset_temporal_ggplots <- vector(mode = "list", length = 12)

for(i in 1:12) {
  
naive_subset_temporal_ggplots[[i]] <- ggplot() +
  geom_raster(data = naive_subset_temporal_list[[i]], aes(x = x, y = y, fill = value)) +
  #scale_fill_viridis_c(direction = 1, option = "C") +
  scale_fill_gradient(low = "white", high = "red") +
  geom_point(data = buffalo_subset[which(buffalo_subset$month == month(dates[i])),] %>% 
               filter(y == 1), aes(x = x1_, y = y1_), size = 0.2, alpha = 0.5) +
  coord_equal() +
  ggtitle(paste("Naive Approach ", naive_subset_temporal_list[[i]]$date, sep = "")) +
  theme_bw() +
  theme(legend.position = "bottom", legend.key.width = unit(1.1, "cm"))

}

for(i in 1:12) print(naive_subset_temporal_ggplots[[i]])

assign(paste("preds_id", unique(buffalo_subset$id), "sub_extent", sep = "_"), naive_subset_temporal_ggplots)

```





```{r}

buffalo_ids <- unique(buffalo_all_covs$id)

```


```{r MEGA LOOP}

tic()
# buffalo_subset <- buffalo_all_covs %>% filter(id == 2005)

buffalo_subset_list <- split(buffalo_all_covs, buffalo_all_covs$id)
clogit_models <- vector(mode = "list", length = length(buffalo_subset_list))
aic_values <- vector(mode = "numeric", length = length(buffalo_subset_list))
temp_coefs_list <- vector(mode = "list", length = length(buffalo_subset_list))

for(x in 1:length(buffalo_subset_list)) {
  
  buffalo_subset <- buffalo_subset_list[[x]]

clogit_model <- buffalo_subset %>% 
  fit_clogit(case_ ~ 
               ndvi_temporal +
               ndwi_temporal +
               veg_herby +
               canopy_01 + 
               # slope_end +
               month_s1:ndvi_temporal +
               month_s2:ndvi_temporal +
               month_s3:ndvi_temporal +
               # month_s4:ndvi_temporal +
               month_c1:ndvi_temporal +
               month_c2:ndvi_temporal +
               month_c3:ndvi_temporal +
               # month_c4:ndvi_temporal +
               month_s1:ndwi_temporal +
               month_s2:ndwi_temporal +
               month_s3:ndwi_temporal +
               # month_s4:ndwi_temporal +
               month_c1:ndwi_temporal +
               month_c2:ndwi_temporal +
               month_c3:ndwi_temporal +
               # month_c4:ndwi_temporal +
               month_s1:veg_herby +
               month_s2:veg_herby +
               month_s3:veg_herby +
               # month_s4:veg_herby +
               month_c1:veg_herby +
               month_c2:veg_herby +
               month_c3:veg_herby +
               # month_c4:veg_herby +
               month_s1:canopy_01 +
               month_s2:canopy_01 +
               month_s3:canopy_01 +
               # month_s4:canopy_01 +
               month_c1:canopy_01 +
               month_c2:canopy_01 +
               month_c3:canopy_01 +
               # month_c4:canopy_01 +
               log_sl_ +
               cos_ta_ +
               strata(step_id_))


clogit_models[[x]] <- clogit_model
print(summary(clogit_model))
print(AIC(clogit_model))
aic_values[[x]] <- AIC(clogit_model)


}

aic_3_harmonics <- sum(aic_values)

toc()

```


### creating temporal coefficients

```{r}

# only run this line once otherwise it will keep deleting individuals from the model stack
clogit_models <- clogit_models[-12]

```




```{r}

harmonic_covs <- vector(mode = "list", length = length(clogit_models))

for(j in 1:length(clogit_models)) {

clogit_model <- clogit_models[[j]]

x_month <- seq(1, 12, by = 0.1)
# x_month <- seq(1, 12, 1)

y_month <- function(x, 
                    lin_coef, 
                    sin_coef1, 
                    sin_coef2,
                    sin_coef3,
                    cos_coef1, 
                    cos_coef2,
                    cos_coef3) {
  
  lin_coef + 
    (sin_coef1 * sin(2 * pi * x / 12)) + 
    (sin_coef2 * sin(4 * pi * x / 12)) + 
    (sin_coef3 * sin(8 * pi * x / 12)) +
    (cos_coef1 * cos(2 * pi * x / 12)) + 
    (cos_coef2 * cos(4 * pi * x / 12)) +
    (cos_coef3 * cos(8 * pi * x / 12))
}


y_ndvi_month <- map_dbl(x_month,
             y_month,
             clogit_model$model$coefficients[1],
             clogit_model$model$coefficients[7],
             clogit_model$model$coefficients[8],
             clogit_model$model$coefficients[9],
             clogit_model$model$coefficients[10],
             clogit_model$model$coefficients[11],
             clogit_model$model$coefficients[12])

y_ndwi_month <- map_dbl(x_month,
             y_month,
             clogit_model$model$coefficients[2],
             clogit_model$model$coefficients[13],
             clogit_model$model$coefficients[14],
             clogit_model$model$coefficients[15],
             clogit_model$model$coefficients[16],
             clogit_model$model$coefficients[17],
             clogit_model$model$coefficients[18])

y_veg_herby <- map_dbl(x_month,
             y_month,
             clogit_model$model$coefficients[3],
             clogit_model$model$coefficients[19],
             clogit_model$model$coefficients[20],
             clogit_model$model$coefficients[21],
             clogit_model$model$coefficients[22],
             clogit_model$model$coefficients[23],
             clogit_model$model$coefficients[24])

y_canopy <- map_dbl(x_month,
             y_month,
             clogit_model$model$coefficients[4],
             clogit_model$model$coefficients[25],
             clogit_model$model$coefficients[26],
             clogit_model$model$coefficients[27],
             clogit_model$model$coefficients[28],
             clogit_model$model$coefficients[29],
             clogit_model$model$coefficients[30])


plot(x_month, y_ndvi_month, type = "l")
abline(h = 0, lty = "dashed")

plot(x_month, y_ndwi_month, type = "l")
abline(h = 0, lty = "dashed")

plot(x_month, y_veg_herby, type = "l")
abline(h = 0, lty = "dashed")

plot(x_month, y_canopy, type = "l")
abline(h = 0, lty = "dashed")

harmonic_covs[[j]] <- data.frame(x_month, y_ndvi_month, y_ndwi_month, y_veg_herby, y_canopy)

}

harmonic_covs_df <- bind_rows(harmonic_covs)
harmonic_covs_df$id <- rep(unique(buffalo_all_covs$id)[-12], each = 111)
# harmonic_covs_df$id <- rep(unique(buffalo_all_covs$id)[-12], each = 12)

# toc()

```



```{r}

ggplot(data = harmonic_covs_df) +
  geom_line(aes(x = x_month, y_ndvi_month, group = id, colour = factor(id))) +
  scale_colour_viridis_d() +
  ggtitle("NDVI") +
  theme_classic()

ggplot(data = harmonic_covs_df) +
  geom_line(aes(x = x_month, y_ndwi_month, group = id, colour = factor(id))) +
  scale_colour_viridis_d() +
  ggtitle("NDWI") +
  theme_classic()

ggplot(data = harmonic_covs_df) +
  geom_line(aes(x = x_month, y_veg_herby, group = id, colour = factor(id))) +
  scale_colour_viridis_d() +
  ggtitle("Herbaceous vegetation") +
  theme_classic()

ggplot(data = harmonic_covs_df) +
  geom_line(aes(x = x_month, y_canopy, group = id, colour = factor(id))) +
  scale_colour_viridis_d() +
  ggtitle("Canopy cover") +
  theme_classic()

```

### Unweighted means

```{r}

ndvi_lin <- c()
ndvi_s1 <- c()
ndvi_s2 <- c()
ndvi_s3 <- c()
ndvi_c1 <- c()
ndvi_c2 <- c()
ndvi_c3 <- c()

ndwi_lin <- c()
ndwi_s1 <- c()
ndwi_s2 <- c()
ndwi_s3 <- c()
ndwi_c1 <- c()
ndwi_c2 <- c()
ndwi_c3 <- c()

herby_lin <- c()
herby_s1 <- c()
herby_s2 <- c()
herby_s3 <- c()
herby_c1 <- c()
herby_c2 <- c()
herby_c3 <- c()

canopy_lin <- c()
canopy_s1 <- c()
canopy_s2 <- c()
canopy_s3 <- c()
canopy_c1 <- c()
canopy_c2 <- c()
canopy_c3 <- c()

for(i in 1:length(clogit_models)) {
  
  ndvi_lin <- c(ndvi_lin, clogit_models[[i]]$model$coefficients[1])
  ndvi_s1 <- c(ndvi_s1, clogit_models[[i]]$model$coefficients[7])
  ndvi_s2 <- c(ndvi_s2, clogit_models[[i]]$model$coefficients[8])
  ndvi_s3 <- c(ndvi_s3, clogit_models[[i]]$model$coefficients[9])
  ndvi_c1 <- c(ndvi_c1, clogit_models[[i]]$model$coefficients[10])
  ndvi_c2 <- c(ndvi_c2, clogit_models[[i]]$model$coefficients[11])
  ndvi_c3 <- c(ndvi_c3, clogit_models[[i]]$model$coefficients[12])
  
  ndwi_lin <- c(ndwi_lin, clogit_models[[i]]$model$coefficients[2])
  ndwi_s1 <- c(ndwi_s1, clogit_models[[i]]$model$coefficients[13])
  ndwi_s2 <- c(ndwi_s2, clogit_models[[i]]$model$coefficients[14])
  ndwi_s3 <- c(ndwi_s3, clogit_models[[i]]$model$coefficients[15])
  ndwi_c1 <- c(ndwi_c1, clogit_models[[i]]$model$coefficients[16])
  ndwi_c2 <- c(ndwi_c2, clogit_models[[i]]$model$coefficients[17])
  ndwi_c3 <- c(ndwi_c3, clogit_models[[i]]$model$coefficients[18])
  
  herby_lin <- c(herby_lin, clogit_models[[i]]$model$coefficients[3])
  herby_s1 <- c(herby_s1, clogit_models[[i]]$model$coefficients[19])
  herby_s2 <- c(herby_s2, clogit_models[[i]]$model$coefficients[20])
  herby_s3 <- c(herby_s3, clogit_models[[i]]$model$coefficients[21])
  herby_c1 <- c(herby_c1, clogit_models[[i]]$model$coefficients[22])
  herby_c2 <- c(herby_c2, clogit_models[[i]]$model$coefficients[23])
  herby_c3 <- c(herby_c3, clogit_models[[i]]$model$coefficients[24])
  
  canopy_lin <- c(canopy_lin, clogit_models[[i]]$model$coefficients[4])
  canopy_s1 <- c(canopy_s1, clogit_models[[i]]$model$coefficients[25])
  canopy_s2 <- c(canopy_s2, clogit_models[[i]]$model$coefficients[26])
  canopy_s3 <- c(canopy_s3, clogit_models[[i]]$model$coefficients[27])
  canopy_c1 <- c(canopy_c1, clogit_models[[i]]$model$coefficients[28])
  canopy_c2 <- c(canopy_c2, clogit_models[[i]]$model$coefficients[29])
  canopy_c3 <- c(canopy_c3, clogit_models[[i]]$model$coefficients[30])
  
}

# ndvi_coefs <- c(mean(ndvi_lin), mean(ndvi_s1), mean(ndvi_s2),
#                 mean(ndvi_s3), mean(ndvi_c1), mean(ndvi_c2), mean(ndvi_c3))

y_ndvi_means <- map_dbl(x_month, y_month, mean(ndvi_lin), mean(ndvi_s1), mean(ndvi_s2),
                mean(ndvi_s3), mean(ndvi_c1), mean(ndvi_c2), mean(ndvi_c3))

y_ndwi_means <- map_dbl(x_month, y_month, mean(ndwi_lin), mean(ndwi_s1), mean(ndwi_s2),
                mean(ndwi_s3), mean(ndwi_c1), mean(ndwi_c2), mean(ndwi_c3))

y_herby_means <- map_dbl(x_month, y_month, mean(herby_lin), mean(herby_s1), mean(herby_s2),
                mean(herby_s3), mean(herby_c1), mean(herby_c2), mean(herby_c3))

y_canopy_means <- map_dbl(x_month, y_month, mean(canopy_lin), mean(canopy_s1), mean(canopy_s2),
                mean(canopy_s3), mean(canopy_c1), mean(canopy_c2), mean(canopy_c3))

ndvi_means <- data.frame(x_month, y_ndvi_means)
ndwi_means <- data.frame(x_month, y_ndwi_means)
herby_means <- data.frame(x_month, y_herby_means)
canopy_means <- data.frame(x_month, y_canopy_means)

```



```{r}

clogit_model_table <- vector(mode = "list", length = length(clogit_models))

for(i in 1:length(clogit_models)) {

  id <- rep(unique(buffalo_all_covs$id)[i], length(clogit_models[[i]]$model$coefficients))
  coef_names <- names(clogit_models[[i]]$model$coefficients)
  coefs <- clogit_models[[i]]$model$coefficients
  vars <- diag(clogit_models[[i]]$model$var)
  weights <- 1/diag(clogit_models[[i]]$model$var)

clogit_model_table[[i]] <- data.frame(id, coef_names, coefs, vars, weights)

}

clogit_covs <- bind_rows(clogit_model_table)

```



```{r}

# clogit_covs %>% dplyr::group_by(coef_names) %>% weighted.mean(x = .$coefs, w = .$weights)

ndvi_lin_df <- clogit_covs %>% filter(coef_names == "ndvi_temporal")

mean(x = ndvi_lin_df$coefs)
weighted.mean(x = ndvi_lin_df$coefs, w = ndvi_lin_df$weights)


unique(clogit_covs$coef_names)[1]

clogit_covs[which(clogit_covs$coef_names == "ndvi_temporal"),]$coefs
clogit_covs[which(clogit_covs$coef_names == "ndvi_temporal"),]$weights

mean <- mean(x = clogit_covs[which(clogit_covs$coef_names == "ndvi_temporal"),]$coefs)
weighted.mean(x = clogit_covs[which(clogit_covs$coef_names == "ndvi_temporal"),]$coefs,
              w = clogit_covs[which(clogit_covs$coef_names == "ndvi_temporal"),]$weights)

```


Loop to calculate means and weighted means 

```{r}

coef <- c()
mean <- c()
w_mean <- c()

for(i in 1:length(unique(clogit_covs$coef_names))) {
  
  coef_i <- unique(clogit_covs$coef_names)[i]

  coef <- c(coef, coef_i)
  
  mean <- c(mean, 
            mean(x = clogit_covs[which(clogit_covs$coef_names == coef_i),]$coefs))
  
  w_mean <- c(w_mean, 
            weighted.mean(x = clogit_covs[which(clogit_covs$coef_names == coef_i),]$coefs,
              w = clogit_covs[which(clogit_covs$coef_names == coef_i),]$weights))

}

clogit_weighted_means <- data.frame(coef, mean, w_mean)

clogit_weighted_means

```

### Weighted means

```{r}

y_ndvi_weighted_means <- map_dbl(x_month, y_month, 
                        clogit_weighted_means[str_detect(clogit_weighted_means$coef, "ndvi"),]$w_mean[1],
                        clogit_weighted_means[str_detect(clogit_weighted_means$coef, "ndvi"),]$w_mean[2],
                        clogit_weighted_means[str_detect(clogit_weighted_means$coef, "ndvi"),]$w_mean[3],
                        clogit_weighted_means[str_detect(clogit_weighted_means$coef, "ndvi"),]$w_mean[4],
                        clogit_weighted_means[str_detect(clogit_weighted_means$coef, "ndvi"),]$w_mean[5],
                        clogit_weighted_means[str_detect(clogit_weighted_means$coef, "ndvi"),]$w_mean[6],
                        clogit_weighted_means[str_detect(clogit_weighted_means$coef, "ndvi"),]$w_mean[7])
                        

y_ndwi_weighted_means <- map_dbl(x_month, y_month, 
                        clogit_weighted_means[str_detect(clogit_weighted_means$coef, "ndwi"),]$w_mean[1],
                        clogit_weighted_means[str_detect(clogit_weighted_means$coef, "ndwi"),]$w_mean[2],
                        clogit_weighted_means[str_detect(clogit_weighted_means$coef, "ndwi"),]$w_mean[3],
                        clogit_weighted_means[str_detect(clogit_weighted_means$coef, "ndwi"),]$w_mean[4],
                        clogit_weighted_means[str_detect(clogit_weighted_means$coef, "ndwi"),]$w_mean[5],
                        clogit_weighted_means[str_detect(clogit_weighted_means$coef, "ndwi"),]$w_mean[6],
                        clogit_weighted_means[str_detect(clogit_weighted_means$coef, "ndwi"),]$w_mean[7])

y_herby_weighted_means <- map_dbl(x_month, y_month, 
                        clogit_weighted_means[str_detect(clogit_weighted_means$coef, "veg"),]$w_mean[1],
                        clogit_weighted_means[str_detect(clogit_weighted_means$coef, "veg"),]$w_mean[2],
                        clogit_weighted_means[str_detect(clogit_weighted_means$coef, "veg"),]$w_mean[3],
                        clogit_weighted_means[str_detect(clogit_weighted_means$coef, "veg"),]$w_mean[4],
                        clogit_weighted_means[str_detect(clogit_weighted_means$coef, "veg"),]$w_mean[5],
                        clogit_weighted_means[str_detect(clogit_weighted_means$coef, "veg"),]$w_mean[6],
                        clogit_weighted_means[str_detect(clogit_weighted_means$coef, "veg"),]$w_mean[7])

y_canopy_weighted_means <- map_dbl(x_month, y_month, 
                        clogit_weighted_means[str_detect(clogit_weighted_means$coef, "canopy"),]$w_mean[1],
                        clogit_weighted_means[str_detect(clogit_weighted_means$coef, "canopy"),]$w_mean[2],
                        clogit_weighted_means[str_detect(clogit_weighted_means$coef, "canopy"),]$w_mean[3],
                        clogit_weighted_means[str_detect(clogit_weighted_means$coef, "canopy"),]$w_mean[4],
                        clogit_weighted_means[str_detect(clogit_weighted_means$coef, "canopy"),]$w_mean[5],
                        clogit_weighted_means[str_detect(clogit_weighted_means$coef, "canopy"),]$w_mean[6],
                        clogit_weighted_means[str_detect(clogit_weighted_means$coef, "canopy"),]$w_mean[7])

ndvi_weighted_means <- data.frame(x_month, y_ndvi_weighted_means)
ndwi_weighted_means <- data.frame(x_month, y_ndwi_weighted_means)
herby_weighted_means <- data.frame(x_month, y_herby_weighted_means)
canopy_weighted_means <- data.frame(x_month, y_canopy_weighted_means)

```




```{r}

ggplot() +
  geom_hline(yintercept = 0, linetype = "dashed") +
  geom_line(data = harmonic_covs_df, aes(x = x_month, y_ndvi_month, group = id, colour = factor(id))) +
  scale_colour_viridis_d() +
  scale_x_continuous("Month", breaks = seq(1,12,1)) +
  scale_y_continuous("Coefficient value") +
  geom_line(data = ndvi_means, aes(x = x_month, y = y_ndvi_means), size = 2, colour = "blue") +
  geom_line(data = ndvi_weighted_means, aes(x = x_month, y = y_ndvi_weighted_means), size = 2, colour = "red") +
  ggtitle("NDVI") +
  theme_bw()

ggplot() +
  geom_hline(yintercept = 0, linetype = "dashed") +
  geom_line(data = harmonic_covs_df, aes(x = x_month, y_ndwi_month, group = id, colour = factor(id))) +
  scale_colour_viridis_d() +
  scale_x_continuous("Month", breaks = seq(1,12,1)) +
  scale_y_continuous("Coefficient value") +
  geom_line(data = ndwi_means, aes(x = x_month, y = y_ndwi_means), size = 2, colour = "blue") +
  geom_line(data = ndwi_weighted_means, aes(x = x_month, y = y_ndwi_weighted_means), size = 2, colour = "red") +
  ggtitle("NDWI") +
  theme_bw()

ggplot() +
  geom_hline(yintercept = 0, linetype = "dashed") +
  geom_line(data = harmonic_covs_df, aes(x = x_month, y_veg_herby, group = id, colour = factor(id))) +
  scale_colour_viridis_d() +
  scale_x_continuous("Month", breaks = seq(1,12,1)) +
  scale_y_continuous("Coefficient value") +
  geom_line(data = herby_means, aes(x = x_month, y = y_herby_means), size = 2, colour = "blue") +
  geom_line(data = herby_weighted_means, aes(x = x_month, y = y_herby_weighted_means), size = 2, colour = "red") +
  ggtitle("Herbaceous vegetation") +
  theme_bw()

ggplot() +
  geom_hline(yintercept = 0, linetype = "dashed") +
  geom_line(data = harmonic_covs_df, aes(x = x_month, y_canopy, group = id, colour = factor(id))) +
  scale_colour_viridis_d() +
  scale_x_continuous("Month", breaks = seq(1,12,1)) +
  scale_y_continuous("Coefficient value") +
  geom_line(data = canopy_means, aes(x = x_month, y = y_canopy_means), size = 2, colour = "blue") +
  geom_line(data = canopy_weighted_means, aes(x = x_month, y = y_canopy_weighted_means), size = 2, colour = "red") +
  ggtitle("Canopy cover") +
  theme_bw()

```




```{r}

years <- c(rep(2018, 5), rep(2019, 7))
months <- c(seq(8, 12, 1), seq(1, 7, 1))
day <- rep(15, 12)
dates <- make_datetime(year = years, month = months, day = day, tz = "Australia/Queensland")


# ndvi_means %>% slice(seq(1, 111, 10)) %>% dplyr::select(2)

temp_coefs <- data.frame("date" = dates, 
                         "ndvi" = ndvi_weighted_means %>% slice(seq(1, 111, 10)) %>% dplyr::select(2), 
                         "ndwi" = ndwi_weighted_means %>% slice(seq(1, 111, 10)) %>% dplyr::select(2), 
                         "veg_herby" = herby_weighted_means %>% slice(seq(1, 111, 10)) %>% dplyr::select(2), 
                         "canopy" = canopy_weighted_means %>% slice(seq(1, 111, 10)) %>% dplyr::select(2))


layers <- stack()

for(i in 1:12) {

resources <- raster::stack(ndvi_raster_amt[[which(getZ(ndvi_raster_amt) == temp_coefs$date[i])]], 
                           ndwi_raster_amt[[which(getZ(ndwi_raster_amt) == temp_coefs$date[i])]], 
                           veg_herby, 
                           canopy_01)

naive <- raster(resources)
naive <- raster::setValues(naive, 0)
  
for (j in 1:4) {
  naive <- naive + temp_coefs[i,][[j + 1]] * resources[[j]]
}
  
naive_norm <- exp(naive)/cellStats(exp(naive), stat = "sum")
layers <- stack(layers, naive_norm)

}

layers <- mask(layers, water, maskvalue = 1)
layers <- raster::setZ(layers, dates)

raster::plot(layers, col = brewer.pal(9, "Reds"), main = getZ(layers))
hist(layers, breaks = 100)
names(layers) <- getZ(layers)

```


Create dataframe so ggplot can use it

```{r}

naive_norm_df <- as.data.frame(layers, colnames = names(layers), xy = TRUE)

```



```{r}

naive_2019.01.15 <- ggplot() +
  geom_raster(data = naive_norm_df, aes(x = x, y = y, fill = naive_norm_df[,i + 2])) +
  scale_fill_viridis_c(direction = 1, option = "D") +
  # scale_fill_gradient(low = "white", high = "red") +
  coord_equal() +
  ggtitle("Naive Approach") +
  theme_bw() +
  theme(legend.position = "bottom", legend.key.width = unit(1.1, "cm"))

naive_2019.01.15

```


Create and store all predictions with ggplots.

```{r}

naive_pred_ggplots <- vector(mode = "list", length = nlayers(layers))

for(i in 1:nlayers(layers)) {
  
  message(i)

naive_pred_ggplots[[i]] <- local({
  
  i <- i
  
  naive_plot <- ggplot() +
  geom_raster(data = naive_norm_df, 
              aes(x = x, y = y, fill = naive_norm_df[,i + 2])) +
  scale_fill_viridis_c(direction = 1, option = "D") +
  # scale_fill_gradient("Habitat Suitability", low = "white", high = "red") +
  coord_equal() +
  ggtitle(paste("Naive Approach", gsub('X','',colnames(naive_norm_df)[i + 2]), sep = " ")) +
  theme_bw() +
  theme(legend.position = "bottom", legend.key.width = unit(1.1, "cm"))
  
  print(naive_plot)
  
})

}

# naive_pred_ggplots[[1]]
# naive_pred_ggplots[[5]]

naive_pred_ggplots

```











```{r}

### create date vector (should be the same for all ids)

years <- c(rep(2018, 5), rep(2019, 7))
months <- c(seq(8, 12, 1), seq(1, 7, 1))
day <- rep(15, 12)
dates <- make_datetime(year = years, month = months, day = day, tz = "Australia/Queensland")


### set up predictions

temp_coefs <- data.frame("date" = dates, 
                         "ndvi" = y_ndvi_month, 
                         "ndwi" = y_ndwi_month, 
                         "veg_herby" = y_veg_herby, 
                         "canopy" = y_canopy)

temp_coefs_list[[x]] <- temp_coefs


### generate predictions

layers <- stack()

for(i in 1:12) {

resources <- raster::stack(ndvi_raster_amt[[which(getZ(ndvi_raster_amt) == temp_coefs$date[i])]], 
                           ndwi_raster_amt[[which(getZ(ndwi_raster_amt) == temp_coefs$date[i])]], 
                           veg_herby, 
                           canopy_01)

naive <- raster(resources)
naive <- raster::setValues(naive, 0)
  
for (j in 1:4) {
  naive <- naive + temp_coefs[i,][[j + 1]] * resources[[j]]
}
  
naive_norm <- exp(naive)/cellStats(exp(naive), stat = "sum")
layers <- stack(layers, naive_norm)

}

layers <- mask(layers, water, maskvalue = 1)
layers <- raster::setZ(layers, dates)
# getZ(layers) 



layers_df <- as.data.frame(layers, xy = TRUE)
colnames(layers_df) <- c("x", "y", as.character(as_date(dates)))
naive_temporal_df <- pivot_longer(layers_df, cols = 3:14, names_to = "date")

naive_temporal_list <- split(x = naive_temporal_df, f = naive_temporal_df$date)




naive_temporal_ggplots <- vector(mode = "list", length = 12)

for(i in 1:12) {
  
naive_temporal_ggplots[[i]] <- ggplot() +
  geom_raster(data = naive_temporal_list[[i]], aes(x = x, y = y, fill = value)) +
  #scale_fill_viridis_c(direction = 1, option = "C") +
  scale_fill_gradient(low = "white", high = "red") +
  geom_point(data = buffalo_subset[which(buffalo_subset$month == month(dates[i])),] %>% 
               filter(y == 1), aes(x = x1_, y = y1_), size = 0.2, alpha = 0.5) +
  coord_equal() +
  ggtitle(paste("Naive Approach ", naive_temporal_list[[i]]$date, sep = "")) +
  theme_bw() +
  theme(legend.position = "bottom", legend.key.width = unit(1.1, "cm"))

}


for(i in 1:12) print(naive_temporal_ggplots[[i]])

# assign(paste("preds_id", unique(buffalo_subset$id), sep = "_"), naive_temporal_ggplots)




### predictions over subset

extent_subset <- raster(xmn = min(buffalo_subset$x2_), 
                        xmx = max(buffalo_subset$x2_), 
                        ymn = min(buffalo_subset$y2_), 
                        ymx = max(buffalo_subset$y2_), 
		crs = 3112, vals = 0)

# plot(extent_subset)

layers_subset <- raster::crop(x = layers, y = extent_subset)
# plot(layers_subset)

layers_subset_df <- as.data.frame(layers_subset, xy = TRUE)
colnames(layers_subset_df) <- c("x", "y", as.character(as_date(dates)))
naive_subset_temporal_df <- pivot_longer(layers_subset_df, cols = 3:14, names_to = "date") # %>% dplyr::arrange(date)

naive_subset_temporal_list <- split(x = naive_subset_temporal_df, f = naive_subset_temporal_df$date)


naive_subset_temporal_ggplots <- vector(mode = "list", length = 12)

for(i in 1:12) {
  
naive_subset_temporal_ggplots[[i]] <- ggplot() +
  geom_raster(data = naive_subset_temporal_list[[i]], aes(x = x, y = y, fill = value)) +
  #scale_fill_viridis_c(direction = 1, option = "C") +
  scale_fill_gradient(low = "white", high = "red") +
  geom_point(data = buffalo_subset[which(buffalo_subset$month == month(dates[i])),] %>% 
               filter(y == 1), aes(x = x1_, y = y1_), size = 0.2, alpha = 0.5) +
  coord_equal() +
  ggtitle(paste("Naive Approach ", naive_subset_temporal_list[[i]]$date, sep = "")) +
  theme_bw() +
  theme(legend.position = "bottom", legend.key.width = unit(1.1, "cm"))

}

for(i in 1:12) print(naive_subset_temporal_ggplots[[i]])

# assign(paste("preds_id", unique(buffalo_subset$id), "sub_extent", sep = "_"), naive_subset_temporal_ggplots)

#}

toc()

# for(i in 1:length(naive_temporal_ggplots) print(naive_temporal_ggplots)
# for(i in 1:length(naive_subset_temporal_ggplots) print(naive_subset_temporal_ggplots)
    
```














```{r}

raster::plot(naive_norm, col = brewer.pal(9, "Reds"))
hist(naive_norm, breaks = 100)

naive_norm_df <- as.data.frame(naive_norm, xy = TRUE)
  
naive <- ggplot() +
  geom_raster(data = naive_norm_df, aes(x = x, y = y, fill = layer)) +
  #scale_fill_viridis_c(direction = 1, option = "C") +
  scale_fill_gradient(low = "white", high = "red") +
  coord_equal() +
  ggtitle("Naive Approach") +
  theme_bw() +
  theme(legend.position = "bottom", legend.key.width = unit(1.1, "cm"))

naive

#naive_norm_2005 <- naive_norm
#naive_norm_2014 <- naive_norm

```



```{r}
  
naive <- raster(resources)
naive <- raster::setValues(naive, 0)
  
for (i in 1:4) {
  naive <- naive + emp_coefs[[i]] * resources[[i]]
}
  
#raster::plot(naive, col = brewer.pal(9, "Reds"))
naive_norm <- exp(naive)/cellStats(exp(naive), stat = "sum")
raster::plot(naive_norm, col = brewer.pal(9, "Reds"))
hist(naive_norm, breaks = 100)

naive_norm_df <- as.data.frame(naive_norm, xy = TRUE)
  
naive <- ggplot() +
  geom_raster(data = naive_norm_df, aes(x = x, y = y, fill = layer)) +
  #scale_fill_viridis_c(direction = 1, option = "C") +
  scale_fill_gradient(low = "white", high = "red") +
  coord_equal() +
  ggtitle("Naive Approach") +
  theme_bw() +
  theme(legend.position = "bottom", legend.key.width = unit(1.1, "cm"))

naive

#naive_norm_2005 <- naive_norm
#naive_norm_2014 <- naive_norm

```



```{r}

pde <- raster(resources)
pde <- raster::setValues(pde, 0)

for (i in 1:5) {
  pde <- pde + (2 * emp_coefs[[i]] * resources[[i]])
}

#raster::plot(pde, col = brewer.pal(9, "Reds"))
pde_norm <- exp(pde)/cellStats(exp(pde), stat = "sum")
raster::plot(pde_norm, col = brewer.pal(9, "Reds"))
hist(pde_norm, breaks = 100)

pde_norm_df <- as.data.frame(pde_norm, xy = TRUE)

pde <- ggplot() +
  geom_raster(data = pde_norm_df, aes(x = x, y = y, fill = layer)) +
  #scale_fill_viridis_c() +
  scale_fill_gradient(low = "white", high = "red") +
  coord_equal() +
  ggtitle("PDE Approach") +
  theme_bw() +
  theme(legend.position = "bottom", legend.key.width = unit(1.1, "cm"))

pde

#pde_norm_2005 <- pde_norm
#pde_norm_2014 <- pde_norm
  
```



```{r}

empirical_steps <- buffalo_all_covs %>% filter(y == 1) %>% .$sl_ 
empirical_angles <- buffalo_all_covs %>% filter(y == 1) %>% .$ta_

empirical_pairs <- bind_cols("steps" = empirical_steps, "angles" = empirical_angles) %>% drop_na()

slice_sample(empirical_pairs, n = 5, replace = T)

simulate_ssf <- function(n_steps, n_ch, l = 1, coef, xy0, resc) {
  #sl <- rexp(n_steps * n_ch, rate = l)
  #sl <- rgamma(n_steps * n_ch, shape = 1.5, scale = 5)
  #ta <- runif(n_steps * n_ch, -pi, pi)
  sl <- unlist(as.vector(slice_sample(empirical_pairs, n = n_steps * n_ch, replace = T)[,1]))
  ta <- unlist(as.vector(slice_sample(empirical_pairs, n = n_steps * n_ch, replace = T)[,2]))
  #stp_ta <- slice_sample(empirical_pairs, n = n_steps * n_ch, replace = T)
  #sl <- as.vector(stp_ta[,1])
  #ta <- as.numeric(stp_ta[,2])
  #sl <- base::sample(x = empirical_steps, size = n_steps * n_ch, replace = TRUE)
  #ta <- base::sample(x = empirical_angles, size = n_steps * n_ch, replace = TRUE)
  steps <- rep(1:n_steps, each = n_ch)
  x_0 <- xy0[1]
  y_0 <- xy0[2]
  x_s <- sl * sin(ta)
  y_s <- sl * cos(ta)
  x <- rep(NA, n_steps)
  y <- rep(NA, n_steps)
  x[1] <- x_0
  y[1] <- y_0
  # multiply resources with selection coef
  for (i in 1:length(coef)) resc[[i]] <- resc[[i]] * coef[i]
  
  #i = 3
  
  for (i in 2:n_steps) {
    x_pos <- (x[i - 1] + sl[steps == i] * sin(ta[steps == i])) %% extent(resc)[2] # adding the modulo operator %% ensures a wrapped/toroid landscape, but the origin must be at (0,0)
    y_pos <- (y[i - 1] + sl[steps == i] * cos(ta[steps == i])) %% extent(resc)[4]
    p <- exp(rowSums(raster::extract(resc, cbind(x_pos, y_pos))))
    p[is.na(p)] <- 0
    w <- sample(n_ch, 1, prob = p)
    x[i] <- x_pos[w]
    y[i] <- y_pos[w]
  }
  data_frame(x = x, y = y)
}

```



```{r}

start_unif <- cbind(runif(100, min = extent(resources)[1], max = extent(resources)[2]), runif(100, min = extent(resources)[3], max = extent(resources)[4]))

#simulate_ssf <- function(n_steps, n_ch, l = 1, coef, xy0, resc) {

tic()
stps <- map(1:100, function(i) 
  simulate_ssf(n_steps = 1e3, n_ch = 50, l = 1, coef = emp_coefs, xy0 = start_unif[i,], resc = resources)
  )
toc()

# 50 individuals, n_steps = 1e4, n_ch = 50 - 3364.03 sec elapsed
 
# simulate_ssf(1000, 1, 1, omgs[i, ], start_unif[i,], resc)
  
  # stps <- map(1:50, function(i) 
  #   #    simulate_ssf(round(runif(1, 25, 200)), 200, 2, 1, omgs[i, ], c(200, 200), resc)
  #   #simulate_ssf <- function(n_steps, n_ch, l = 1, coef, xy0, resc)
  #   #simulate_ssf(1000, 100, 1, omgs[i, ], start_omgs[i,], resc)
  #   simulate_ssf(1000, 10, 1, omgs[i, ], start_unif[i,], resc)
  # )

animals <- data_frame(
  id = paste0("a", 1:100),
  track = map(stps, ~ track(x = .$x, y = .$y, t = ymd_hm("2022-01-01 00:00") + hours(1:nrow(.))))
)



sim_data <- unnest(animals, cols = track)

#sim_data <- data.frame(x = stps$x, y = stps$y, t = ymd_hm("2022-01-01 00:00") + hours(1:nrow(stps)))
# sim_data1 %>% transmute(id = "a0", x_ = x, y_ = y, t_ = t)
# 
# sim_all <- bind_rows(sim_data1 %>% transmute(id = "a0", x_ = x, y_ = y, t_ = t), sim_data)
# sim_data <- sim_all
#sim_20_inds_1000_50 <- sim_data


# write_csv(sim_data, "outputs/buffalo_id2018_bcrw_50_1e4_50_2022-09-22.csv")

```



```{r}

plot(resources[[1]])
points(x = sim_data$x_, y = sim_data$y_)


ndvi_df <- as.data.frame(resources[[1]], xy = TRUE)

#bcrw <- 
ggplot() +
  geom_raster(data = ndvi_df, aes(x = x, y = y, fill = ndvi)) +
  #geom_path(data = sim_data, aes(x = x_, y = y_, colour = id), size = 1) +
  geom_point(data = sim_data, aes(x = x_, y = y_), size = 0.1, colour = "black", alpha = 0.1) +
  geom_point(data = buffalo_subset %>% filter(y == 1), aes(x = x1_, y = y1_ + 1463000), size = 0.1, colour = "red") +
  scale_fill_viridis_c() +
  #scale_fill_gradient(low = "white", high = "darkgreen") +
  coord_equal() +
  ggtitle("Simulation Approach") +
  theme_bw() +
  theme(legend.position = "bottom", legend.key.width = unit(1.1, "cm"))

bcrw


# buffalo_subset %>% filter(y == 1)

```

Generating distribution map

```{r}

points <- resources[[1]]
points[] <- 0

sim_ud_points <- as.matrix(sim_data[,2:3])

counts <- table(raster::cellFromXY(resources[[1]], sim_ud_points))

points[as.numeric(names(counts))] <- counts

plot(points)
# plot(points)
# points(x = sim_data$x, y = sim_data$y)  

points_ud <- points / cellStats(points, stat = "sum")
cellStats(points_ud, stat = "sum")
points_df <- as.data.frame(points_ud, xy = TRUE)
points_df$layer <- points_df$ndvi

bcrw <- 
  ggplot() +
  geom_raster(data = points_df, aes(x = x, y = y, fill = layer)) +
  #geom_point(data = animals_ssf %>% filter(case_ == TRUE), aes(x = x1_, y = y1_, colour = id), size = 0.5) +
  #scale_fill_viridis_c() +
  scale_fill_gradient(low = "white", high = "red") +
  coord_equal() +
  ggtitle("Simulation Approach") +
  theme_bw() +
  theme(legend.position = "bottom", legend.key.width = unit(1.1, "cm"))

bcrw

```


```{r}

naive + pde + bcrw

```
